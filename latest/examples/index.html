<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Martin Burke">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Examples - Discuit.jl</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../assets/Documenter.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">Discuit.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Introduction</a>
                    </li>
                    <li class="active">
                        <a href="./">Examples</a>
                    </li>
                    <li >
                        <a href="../models/">Models</a>
                    </li>
                    <li >
                        <a href="../manual/">Manual</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../models/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/mjb3/Discuit.jl/edit/master/docs/examples.md"><i class="fa fa-github"></i> Edit on GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#discuitjl-examples">Discuit.jl examples</a></li>
            <li><a href="#defining-a-model">Defining a model</a></li>
            <li><a href="#mcmc">MCMC</a></li>
            <li><a href="#convergence-diagnostics">Convergence diagnostics</a></li>
            <li><a href="#simulation">Simulation</a></li>
            <li><a href="#custom-mcmc">Custom MCMC</a></li>
            <li><a href="#references">References</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><a id='Discuit.jl-examples-1'></a></p>
<h1 id="discuitjl-examples">Discuit.jl examples</h1>
<p>The following examples provide a flavour of package's core functionality. See the <a href="../manual/#Discuit.jl-manual-1">Discuit.jl manual</a> for a description of the data types and functions in Discuit, and <a href="../models/#Discuit.jl-models-1">Discuit.jl models</a> for a description of the predefined models available in the package. The tutorial is designed to be run using the <em>REPL</em> but usually it is wise to save code and analyses to a text file for reference later. By convention Julia code files have the extension '.jl'. For example, the file <a href="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/examples/pooley_model.jl">pooley_model.jl</a> (click to download) contains code equivalent to the next section, i.e. it defines a <code>SIS</code> model and stores it in variable <code>model</code> which can then be used just as if we had typed the commands manually.</p>
<p>One way to run a code file is to open a command prompt or terminal and <code>cd</code> to the location of the file. Check the code and save the file. Next start the <em>REPL</em> using the command <code>julia</code>. Finally type the name of the file to run the code:</p>
<p>ADD GIF</p>
<p><a id='Defining-a-model-1'></a></p>
<h2 id="defining-a-model">Defining a model</h2>
<p><code>DiscuitModel</code>s can be created automatically using helper functions or manually by specifying each component. For example the model we are about to create could be generated automatically using <code>generate_model("SIS", [100,1])</code>. However constructing it manually is a helpful exercise for getting to know the package. See <a href="../models/#Discuit.jl-models-1">Discuit.jl models</a> for further details of the <code>generate_model</code> function. We start by examining <code>DiscuitModel</code> in the package documentation:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; using Discuit;</code></pre>


<p>The events in a <code>DiscuitModel</code> are defined by the rates at which they occur and a transition matrix, which governs how individuals migrate between states.  In the basic Kermack-McKendrick <code>SIS</code> (and <code>SIR</code>) model, rates for infection and recovery events respectively are given by:</p>
<p>
<script type="math/tex; mode=display">
r_1 = \theta_1 SI
</script>
</p>
<p>
<script type="math/tex; mode=display">
r_2 = \theta_2 I
</script>
</p>
<p>With the transition matrix:</p>
<p>
<script type="math/tex; mode=display">
T = \begin{bmatrix} -1 & 1 \\ 1 & -1 \end{bmatrix}
</script>
</p>
<p>Note how the first row of the matrix reflects the removal of a susceptible individual from the <code>S</code> state, and migrates them to the second element of the row, the 'I' state. The code required to represent the rates (or 'rate function') and transition matrxi as Julia variables is correspondingly straightforward:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})
           output[1] = parameters[1] * population[1] * population[2]
           output[2] = parameters[2] * population[2]
       end
sis_rf (generic function with 1 method)

julia&gt; t_matrix = [-1 1; 1 -1]
2√ó2 Array{Int64,2}:
 -1   1
  1  -1</code></pre>


<p>The output confirms that <code>sis_rf</code>, a <code>generic function with 1 method</code> has been defined and gives a description of the 2 dimensional <code>Array</code> variable that represents the transition matrix (do not copy and paste these bits when running the code on your own machine). Note that the correct function signature must be used in the implementation for it to be compatible with the package. In this case the function takes three <code>Array</code> parameters of a given type, the first of which is the <code>output</code> variable modified by the function (which is why it does not need to <code>return</code> any actual output variable). Next we define a simple observation function, again with the correct signature:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; obs_fn(population::Array{Int64, 1}) = population
obs_fn (generic function with 1 method)</code></pre>


<p>The default prior distribution is flat and improper, and is equivalent to:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function weak_prior(parameters::Array{Float64, 1})
           parameters[1] &gt; 0.0 || return 0.0
           parameters[2] &gt; 0.0 || return 0.0
           return 1.0
       end
weak_prior (generic function with 1 method)</code></pre>


<p>Finally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation <code>2</code>:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})
           obs_err = 2
           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))
           tmp2 = 2 * obs_err * obs_err
           obs_diff = y[2] - population[2]
           return tmp1 - ((obs_diff * obs_diff) / tmp2)
       end
si_gaussian (generic function with 1 method)</code></pre>


<p>We can now define a model. We must also specify the <code>initial_condition</code> which represents the state of the population at the origin of each trajectory. A final parameter declared inline is an optional index for the <code>t0</code> parameter (ignore for now):</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; initial_condition = [100, 1]
2-element Array{Int64,1}:
 100
   1

julia&gt; model = DiscuitModel(&quot;SIS&quot;, initial_condition, sis_rf, t_matrix, obs_fn, weak_prior, si_gaussian, 0);</code></pre>


<p><a id='MCMC-1'></a></p>
<h2 id="mcmc">MCMC</h2>
<p>The following example is based on that published by Pooley et al. (2015) in the paper that introduces the model based proposal method. The observations data simulated by Pooley can be downloaded <a href="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/data/pooley.csv">here</a> and saved, e.g. to <code>path/to/data/</code>. Next, load the observations data using:</p>
<pre class="codehilite"><code>y = get_observations(&quot;path/to/data/pooley.csv&quot;)</code></pre>


<p>Now we can run an MCMC analysis based on the simulated datset:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_met_hastings_mcmc(model, y, [0.0025, 0.12]);
running MCMC...
 finished (sample Œº = [0.0008798261748757208, 0.029924133112822403])</code></pre>


<p>Visual inspection of the Markov chain using the traceplot is one way of assessing the convergence of the algorithm:</p>
<pre class="codehilite"><code>julia&gt; plot_parameter_trace(rs, 1)</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/jl_traceplot.png" alt="MCMC traceplots" height="220"/></p>
<p>The marginal distribution of parameters can be plotted by calling:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; plot_parameter_marginal(rs, 1)
‚îå Warning: The keyword parameter `bins` is deprecated, use `nbins` instead
‚îÇ   caller = ip:0x0
‚îî @ Core :-1
                       ‚îå                                        ‚îê
      [0.001 , 0.0015) ‚î§‚ñá 295
      [0.0015, 0.002 ) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3378
      [0.002 , 0.0025) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 6960
      [0.0025, 0.003 ) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 7700
      [0.003 , 0.0035) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 7265
      [0.0035, 0.004 ) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 5425
      [0.004 , 0.0045) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3148
      [0.0045, 0.005 ) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 2092
      [0.005 , 0.0055) ‚î§‚ñá‚ñá‚ñá‚ñá‚ñá 1023
      [0.0055, 0.006 ) ‚î§‚ñá‚ñá‚ñá 675
      [0.006 , 0.0065) ‚î§‚ñá‚ñá 494
   Œ∏‚ÇÅ [0.0065, 0.007 ) ‚î§‚ñá 271
      [0.007 , 0.0075) ‚î§ 68
      [0.0075, 0.008 ) ‚î§‚ñá 138
      [0.008 , 0.0085) ‚î§ 76
      [0.0085, 0.009 ) ‚î§ 80
      [0.009 , 0.0095) ‚î§ 111
      [0.0095, 0.01  ) ‚î§‚ñá 273
      [0.01  , 0.0105) ‚î§‚ñá 195
      [0.0105, 0.011 ) ‚î§‚ñá 133
      [0.011 , 0.0115) ‚î§ 67
      [0.0115, 0.012 ) ‚î§ 77
      [0.012 , 0.0125) ‚î§ 57
                       ‚îî                                        ‚îò
                                        samples</code></pre>


<p>Plotting the data with third party packages such as PyPlot is simple:</p>
<pre class="codehilite"><code>using PyPlot
x = mcmc.samples[mcmc.adapt_period:size(mcmc.samples, 1), parameter]
plt[:hist](x, 30)
xlabel(string(&quot;\$\\theta_&quot;, parameter, &quot;\\$&quot;))
ylabel(&quot;density&quot;)</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/marginals.png" alt="MCMC traceplots" height="240"/></p>
<p>A pairwise representation can be produced by calling <code>plot_parameter_heatmap</code> (see below for an example).</p>
<p><a id='Autocorrelation-1'></a></p>
<h3 id="autocorrelation">Autocorrelation</h3>
<p>Autocorrelation can be used to help determine how well the algorithm mixed by using <code>compute_autocorrelation</code>. The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:</p>
<p>
<script type="math/tex; mode=display">
R_l  = \frac{\textrm{E} [(X_i - \bar{X})(X_{i+l} - \bar{X})]}{\sigma^2}
</script>
</p>
<p>for any given lag <code>l</code>. The modified formula for multiple chains is given by:</p>
<p>
<script type="math/tex; mode=display">
R_{b,l} = \frac{\textrm{E} [ (X_i - \bar{X}_b) ( X_{i + l} - \bar{X}_b ) ]}{\sigma^2_b}
</script>
</p>
<p>
<script type="math/tex; mode=display">
\sigma^2_b = \textrm{E} [(X_i - \bar{X}_b)^2]
</script>
</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; ac = compute_autocorrelation(rs);

julia&gt; plot_autocorrelation(ac)
                   Œ∏ autocorrelation
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     4 ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚¢Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†à‚†≥‚¢Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ì‚†¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†ì‚†í‚†¢‚†§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
   R   ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ì‚†§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†ì‚†¢‚†§‚†§‚¢§‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†à‚†≥‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†ë‚†í‚†¶‚¢Ñ‚£Ä‚£Ä‚£Ä‚£Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†≤‚¢§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†≤‚†§‚£Ñ‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ë‚†≤‚¢§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ë‚†¶‚¢Ñ‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
     2 ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†í‚†í‚†í‚†§‚†§‚†§‚†§‚¢Ñ‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       0                                     2000
                          lag</code></pre>


<p>Note that the latter formulation (for multiple chains) is likely to give a more accurate indication of algorithm performance. The code is virtually identical. Just replace <code>rs</code> with the results of a call to <code>run_gelman_diagnostic</code>.</p>
<p><a id='Convergence-diagnostics-1'></a></p>
<h2 id="convergence-diagnostics">Convergence diagnostics</h2>
<p>The goal of an MCMC analysis is to construct a Markov chain that has the target distribution as its equilibrium distribution, i.e. it has converged. However assessing whether this is the case can be challenging since we do not know the target distribution. Visual inspection of the Markov chain may not be sufficient to diagnose convergence, particularly where the target distribution has local optima. Automated convergence diagnostics are therefore integrated closely with the MCMC functionality in Discuit; the Geweke test for single chains and the Gelman-Rubin for multiple chains. Just like autocorrelation, the latter, provided that the chains have been initialised with over dispersed parameters (with respect to the target distribution), provides a more reliable indication of algorithm performance (in this case, convergence).</p>
<p><a id='Geweke-test-of-stationarity-1'></a></p>
<h3 id="geweke-test-of-stationarity">Geweke test of stationarity</h3>
<p>The Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain (see Geweke, 1992; Cowles, 1996). It is given by:</p>
<p>
<script type="math/tex; mode=display">
z = \frac{\bar{\theta}_{i, \alpha} - \bar{\theta}_{i, \beta}}{\sqrt{Var(\theta_{i, \alpha})+Var(\theta_{i, \beta})})}
</script>
</p>
<p>Geweke statistics are computed automatically for analyses run in Discuit and can be accessed directly (i.e. <code>rs.geweke</code>) or else inspected using one of the built in tools, e.g:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; plot_geweke_series(rs)
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      2 ‚îÇ‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
   z    ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†â‚†â‚†â‚†â‚°â‚†â‚†â‚†â‚°ç‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†ã‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚°ç‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚îÇ
        ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
     -1 ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        0                                    20000</code></pre>


<p>Note that the results of MCMC analyses, including Geweke statistics, can be saved to file for analysis in the companion <a href="https://mjb3.github.io/Discuit/">R package</a>. In Julia, run:</p>
<pre class="codehilite"><code>print_mcmc_results(rs, &quot;path/to/mcmc/data/&quot;)</code></pre>


<p>Now, in R, run:</p>
<pre class="codehilite"><code>library(Discuit)
library(gridExtra)
rs = LoadMcmcResults(&quot;path/to/mcmc/data/&quot;)
tgt = c(0.003, 0.1)
grid.arrange(PlotGewekeSeries(rs), PlotParameterHeatmap(rs, 1, 2, tgt), nrow = 1)</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/geweke_heatmap.png" alt="MCMC analysis" height="240"/></p>
<p><a id='Gelman-Rubin-convergence-diagnostic-1'></a></p>
<h3 id="gelman-rubin-convergence-diagnostic">Gelman-Rubin convergence diagnostic</h3>
<p>The Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance (Gelman et al, 1992, 2014). The <em>estimated scale reduction</em> statistic (sometimes referred to as <em>potential scale reduction factor</em>) is calculated for each parameter in the model.</p>
<p>Let $\bar{\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\theta$, within chain variance between chain variance respectively for $M$ Markov chains:</p>
<p>
<script type="math/tex; mode=display">
W = \frac{1}{M} \sum_{i = 1}^M \sigma^2_i
</script>
</p>
<p>
<script type="math/tex; mode=display">
B = \frac{N}{M - 1} \sum_{i = 1}^M (\hat{\theta}_i - \hat{\theta})^2
</script>
</p>
<p>The estimated scale reduction statistic is given by:</p>
<p>
<script type="math/tex; mode=display">
R = \sqrt{\frac{d + 3}{d + 1} \frac{N-1}{N} + (\frac{M+1}{MN} \frac{B}{W})}
</script>
</p>
<p>where the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_gelman_diagnostic(model, y, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);
running gelman diagnostic... (3 chains)
 chain 1 complete on thread 1
 chain 2 complete on thread 1
 chain 3 complete on thread 1
 finished (sample Œº = [0.000779, 0.0263]).</code></pre>


<p><a id='Simulation-1'></a></p>
<h2 id="simulation">Simulation</h2>
<p>The main purpose of the simulation functionality included in Discuit is to provide a source of simulated observations data for evaluation and validation of the MCMC functionality. However simulation can also be an interesting way to explore and better understand the dynamics of the model.</p>
<p>To produce the Lotka-Volterra example given in the paper use:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; model = generate_model(&quot;LOTKA&quot;, [79, 71]);

julia&gt; xi = gillespie_sim(model, [0.5, 0.0025, 0.3]);
running simulation...
 finished (17520 events).

julia&gt; plot_trajectory(xi)
                                PN simulation
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              500 ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ P
                  ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ N
                  ‚îÇ‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚†Ä‚¢∏‚¢ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚†Ä‚¢∏‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚¢Ä‚¢∏‚¢∏‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†á‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£∑‚†Ä‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚¢∏‚°è‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ü‚¢π‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∂‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚£á‚†Ä‚†Ä‚†Ä‚¢∞‚†ø‚°Ñ‚†Ä‚†Ä‚îÇ
   population     ‚îÇ‚†Ä‚°û‚£ß‚†Ä‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†á‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†ô‚°á‚†Ä‚†Ä‚¢∏‚¢∂‚£¥‚°Ñ‚†Ä‚†Ä‚¢†‚£æ‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚£∏‚†Ä‚°á‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚°á‚£ø‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚¢≥‚†Ä‚†Ä‚†Ä‚¢Ä‚°º‚†Ä‚¢≥‚†Ä‚†Ä‚°è‚†à‚†Å‚¢≥‚†Ä‚†Ä‚¢∏‚£ø‚°Ñ‚†∏‚°Ñ‚†Ä‚£∞‚£ª‚†Ä‚¢π‚†Ä‚†Ä‚îÇ
                  ‚îÇ‚†Ä‚£á‚£ø‚†Ä‚†à‚£ß‚†Ä‚†Ä‚£∏‚£ª‚£ß‚†Ä‚¢∏‚°Ñ‚†Ä‚†Ä‚£∏‚¢ß‚†Ä‚¢∏‚°Ñ‚¢†‚°á‚†Ä‚†Ä‚†ò‚°á‚†Ä‚°û‚°á‚°á‚†Ä‚£á‚†Ä‚°è‚°è‚°á‚†à‚°á‚†Ä‚îÇ
                  ‚îÇ‚¢∏‚¢π‚¢∏‚†Ä‚†Ä‚†ò‚£á‚¢Ä‚£Ø‚°á‚¢∏‚°Ä‚†Ä‚¢≥‚£†‚¢∂‚†ü‚†∏‚°Ñ‚†Ä‚¢ø‚£æ‚¢∑‚¢Ä‚†Ä‚†Ä‚¢ß‚†Ä‚£∑‚†É‚°á‚†Ä‚¢∏‚¢Ä‚£∑‚†É‚°á‚†Ä‚¢π‚°Ä‚îÇ
                  ‚îÇ‚¢∏‚¢∏‚†à‚°á‚†Ä‚†Ä‚†∏‚£æ‚†ü‚†Å‚†à‚£á‚†Ä‚†Ä‚¢ª‚°ü‚†Ä‚†Ä‚¢ß‚†Ä‚¢Ä‚°á‚†ò‚†ª‚£¶‚†Ä‚†ò‚¢æ‚°ø‚†Ä‚¢ß‚†Ä‚†ò‚£æ‚°æ‚†Ä‚¢ß‚†Ä‚†Ä‚¢≥‚îÇ
                  ‚îÇ‚£è‚°û‚†Ä‚£á‚†Ä‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚¢π‚°Ä‚¢∞‚†ã‚†Ä‚†Ä‚†Ä‚†ò‚°Ü‚°æ‚†Ä‚†Ä‚†Ä‚†∏‚£Ü‚£¥‚†è‚†Ä‚†Ä‚¢∏‚†Ä‚¢Ä‚°ø‚†É‚†Ä‚†∏‚°Ñ‚¢Ä‚£∞‚îÇ
                  ‚îÇ‚†à‚†Ä‚†Ä‚†π‚°¥‚†ü‚†û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†≥‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†õ‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†Å‚†Ä‚†Ä‚†Ä‚†à‚¢ß‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†≥‚†û‚†Å‚îÇ
                0 ‚îÇ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  0                                      100
                                    time</code></pre>


<p>The maximum time of the simulation and number of observations to draw can also be specified, e.g. <code>generate_model("LOTKA", [79, 71], 100.0, 10)</code>.</p>
<p><a id='Custom-MCMC-1'></a></p>
<h2 id="custom-mcmc">Custom MCMC</h2>
<p>In addition to the two proposal algorithms included with the packages by default, Discuit allows for users to develop their own algorithms for data augmented MCMC via the alternative custom MCMC framework, while still taking advantage of features including automated, finite adaptive multivariate Œ∏ proposals.</p>
<p>In some cases may wish to simply tweak the proposal algorithms included in the source code repositories for minor performance gains in certain models, but the custom MCMC framework can also be useful in cases where the augmented data aspects of the model have specific or complex constraints, such as the next example which is based on an analysis of a smallpox outbreak within a closed community in Abakaliki, Nigeria by O'Neill and Roberts (ADD CITATION). First we generate a standard <code>SIR</code> model and set the <code>t0_index = 3</code>:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; model = generate_model(&quot;SIR&quot;, [119, 1, 0]);

julia&gt; model.t0_index = 3;</code></pre>


<p>Next we define the "medium" prior used by O'Neill and Roberts, with some help from the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> package:</p>
<pre class="codehilite"><code class="language-julia-repl">  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
[?25l[2K[?25h Resolving package versions...
  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`
  [31c24e10] + Distributions v0.17.0
  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`
 [no changes]

julia&gt; using Distributions;

julia&gt; p1 = Gamma(10, 0.0001);

julia&gt; p2 = Gamma(10, 0.01);

julia&gt; function prior_density(parameters::Array{Float64, 1})
           return parameters[3] &lt; 0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0
       end
prior_density (generic function with 1 method)

julia&gt; model.prior_density = prior_density;</code></pre>


<p>The observation model is replaced with one that returns <code>log(1)</code> since we will only propose sequences consitent with the observed recoveries and $\pi(\xi | \theta)$ is evaluated automatically by Discuit):</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0
observation_model (generic function with 1 method)

julia&gt; model.observation_model = observation_model;</code></pre>


<p>Next we define an array <code>t</code> to contain the recovery times reported by O'Neill and Roberts and a simple <code>Observations</code> variable which consists of the maximum event time and an empty two dimensional array:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];

julia&gt; y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))
Observations([67.0], [140511477914096])</code></pre>


<p>We also need to define an initial state using the <code>generate_custom_x0</code> function using some parameter values and a vector of event times and corresponding event types, consistent with <code>t</code>:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; evt_tm = Float64[];

julia&gt; evt_tp = Int64[];

julia&gt; for i in 1:(length(t) - 1)# infections at arbitrary t &gt; t0
           push!(evt_tm, -4.0)
           push!(evt_tp, 1)
       end

julia&gt; for i in eachindex(t)     # recoveries
           push!(evt_tm, t[i])
           push!(evt_tp, 2)
       end

julia&gt; x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);</code></pre>


<p>The final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit). Since it is assumed that the total number of events is known we can construct an algorithm that simply changes the time of an event in the trajectory. Events are chosen and new times drawn from uniform distributions ensuring that:</p>
<p>
<script type="math/tex; mode=display">
g(X_{f \rightarrow i}) = g(X_{i \rightarrow f})
</script>
</p>
<p>such that the terms cancel in the Metropolis-Hastings acceptance equation. Some additional information is available regarding the times of recoveries; they are known to within a day. We therefore propose new recovery event times such that they remain within the time frame of a single time unit, which correspond to days in this model:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)
           t0 = xf_parameters.value[model.t0_index]
           ## move
           seq_f = deepcopy(xi.trajectory)
           # choose event and define new one
           evt_i = rand(1:length(xi.trajectory.time))
           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()
           evt_tp = xi.trajectory.event_type[evt_i]
           # remove old one
           splice!(seq_f.time, evt_i)
           splice!(seq_f.event_type, evt_i)
           # add new one
           if evt_tm &gt; seq_f.time[end]
               push!(seq_f.time, evt_tm)
               push!(seq_f.event_type, evt_tp)
           else
               for i in eachindex(seq_f.time)
                   if seq_f.time[i] &gt; evt_tm
                       insert!(seq_f.time, i, evt_tm)
                       insert!(seq_f.event_type, i, evt_tp)
                       break
                   end
               end
           end
           # compute ln g(x)
           prop_lk = 1.0
           ## evaluate full likelihood for trajectory proposal and return
           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)
       end # end of std proposal function
custom_proposal (generic function with 1 method)</code></pre>


<p>We can now run the MCMC analysis:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);
running custom MCMC...
ERROR: UndefVarError: compute_full_log_like not defined</code></pre>


<p>The output from the custom MCMC functionality is in the same format as the those produced using the core functions and thus be analysed in the same way. In this case the results were saved to file and analysed in R, in the manner described above:</p>
<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/cmcmc_trace.png" alt="SIR traceplots" height="220"/></p>
<p>The traceplots indicate good mixing and the results are fairly similar to that obtained by O'Neill and Roberts given the differences in the models used.</p>
<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/cmcmc_geweke_hm.png" alt="SIR traceplots" height="220"/></p>
<p><a id='References-1'></a></p>
<h2 id="references">References</h2>
<p><html>
<head>
<script type="text/javascript" src="https://cdn.rawgit.com/pcooksey/bibtex-js/ef59e62c/src/bibtex_js.js"></script>
</head>
<body>
<textarea id="bibtex_input" style="display:none;">
@article{gillespie_exact_1977,
    title = {Exact stochastic simulation of coupled chemical reactions},
    volume = {81},
    issn = {0022-3654, 1541-5740},
    url = {http://pubs.acs.org/doi/abs/10.1021/j100540a008},
    doi = {10.1021/j100540a008},
    language = {en},
    number = {25},
    urldate = {2017-02-18},
    journal = {The Journal of Physical Chemistry},
    author = {Gillespie, Daniel T.},
    month = dec,
    year = {1977},
    pages = {2340--2361}
}</p>
<p>@incollection{geweke_evaluating_1992,
    title = {Evaluating the {Accuracy} of {Sampling}-{Based} {Approaches} to the {Calculation} of {Posterior} {Moments}},
    abstract = {Data augmentation and Gibbs sampling are two closely related, sampling-based approaches to the calculation of posterior moments. The fact that each produces a sample whose constituents are neither independent nor identically distributed complicates the assessment of convergence and numerical accuracy of the approximations to the expected value of functions of interest under the posterior. In this paper methods from spectral analysis are used to evaluate numerical accuracy formally and construct diagnostics for convergence. These methods are illustrated in the normal linear model with informative priors, and in the Tobit-censored regression model.},
    booktitle = {{IN} {BAYESIAN} {STATISTICS}},
    publisher = {University Press},
    author = {Geweke, John},
    year = {1992},
    pages = {169--193}
}</p>
<p>@article{cowles_markov_1996,
    title = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}: {A} {Comparative} {Review}},
    volume = {91},
    issn = {01621459},
    shorttitle = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}},
    url = {http://www.jstor.org/stable/2291683},
    doi = {10.2307/2291683},
    number = {434},
    urldate = {2018-03-20},
    journal = {Journal of the American Statistical Association},
    author = {Cowles, Mary Kathryn and Carlin, Bradley P.},
    month = jun,
    year = {1996},
    pages = {883}
}</p>
<p>@article{gelman_inference_1992,
    title = {Inference from iterative simulation using multiple sequences},
    journal = {Statistical science},
    author = {Gelman, Andrew and Rubin, Donald B.},
    year = {1992},
    pages = {457--472}
}
@book{gelman_bayesian_2014,
    title = {Bayesian data analysis},
    isbn = {978-1-4398-9820-8 978-1-4398-4096-2},
    language = {English},
    urldate = {2018-03-18},
    author = {Gelman, Andrew and Carlin, John B and Stern, Hal Steven and Dunson, David B and Vehtari, Aki and Rubin, Donald B},
    year = {2014},
    note = {OCLC: 909477393}
}
</textarea>
<div id="bibtex_display"></div>
</body>
</html></p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../assets/mathjaxhelper.js"></script>
        <script src="https://cdn.rawgit.com/pcooksey/bibtex-js/ef59e62c/src/bibtex_js.js"></script>
        <script src="../search/require.js"></script>
        <script src="../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
