<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Martin Burke">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Examples - Discuit.jl</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../assets/Documenter.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">Discuit.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Introduction</a>
                    </li>
                    <li class="active">
                        <a href="./">Examples</a>
                    </li>
                    <li >
                        <a href="../models/">Models</a>
                    </li>
                    <li >
                        <a href="../manual/">Manual</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../models/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/mjb3/Discuit.jl/edit/master/docs/examples.md"><i class="fa fa-github"></i> Edit on GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#discuitjl-examples">Discuit.jl examples</a></li>
            <li><a href="#defining-a-model">Defining a model</a></li>
            <li><a href="#mcmc">MCMC</a></li>
            <li><a href="#autocorrelation">Autocorrelation</a></li>
            <li><a href="#convergence-diagnostics">Convergence diagnostics</a></li>
            <li><a href="#simulation">Simulation</a></li>
            <li><a href="#custom-mcmc">Custom MCMC</a></li>
            <li><a href="#references">References</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><a id='Discuit.jl-examples-1'></a></p>
<h1 id="discuitjl-examples">Discuit.jl examples</h1>
<p>The following examples provide a flavour of package's core functionality. See the <a href="../manual/#Discuit.jl-manual-1">Discuit.jl manual</a> for a description of the data types and functions in Discuit, and <a href="../models/#Discuit.jl-models-1">Discuit.jl models</a> for a description of the predefined models available in the package.</p>
<p><a id='Defining-a-model-1'></a></p>
<h2 id="defining-a-model">Defining a model</h2>
<p><code>DiscuitModel</code>s can be created automatically using helper functions or manually by specifying each component. For example the model we are about to create could be generated automatically using <code>generate_model("SIS", [100,1])</code>. However constructing it manually is a helpful exercise for getting to know the package. See <a href="../models/#Discuit.jl-models-1">Discuit.jl models</a> for further details of the <code>generate_model</code> function. We start by examining <code>DiscuitModel</code> in the package documentation:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; using Discuit;</code></pre>


<p>Next we define a rate function equivalent to that of the basic Kermack-McKendrick <code>SIS</code> (and <code>SIR</code>) model. The event rates for infection and recovery events respectively are given by:</p>
<p>
<script type="math/tex; mode=display">
r_1 = \theta_1 SI
</script>
</p>
<p>
<script type="math/tex; mode=display">
r_2 = \theta_2 I
</script>
</p>
<p>The code is correspondingly straightforward:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})
           output[1] = parameters[1] * population[1] * population[2]
           output[2] = parameters[2] * population[2]
       end
sis_rf (generic function with 1 method)</code></pre>


<p>Note that the correct signature must be used in the implementation for it to be compatible with the package. Next we define a simple observation function, again with the correct signature:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; obs_fn(population::Array{Int64, 1}) = population
obs_fn (generic function with 1 method)</code></pre>


<p>The default prior distribution is flat and improper and is equivalent to:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function weak_prior(parameters::Array{Float64, 1})
           parameters[1] &gt; 0.0 || return 0.0
           parameters[2] &gt; 0.0 || return 0.0
           return 1.0
       end
weak_prior (generic function with 1 method)</code></pre>


<p>Finally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation <code>2</code>:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})
           obs_err = 2
           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))
           tmp2 = 2 * obs_err * obs_err
           obs_diff = y[2] - population[2]
           return tmp1 - ((obs_diff * obs_diff) / tmp2)
       end
si_gaussian (generic function with 1 method)</code></pre>


<p>We can now define a model. The three parameters declared inline are the transition matrix; an optional index for the t0 parameter (ignore for now); and the initial condition which represents the state of the population at the origin of each trajectory:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; model = DiscuitModel(&quot;SIS&quot;, [100, 1], sis_rf, [-1 1; 1 -1], obs_fn, weak_prior, si_gaussian, 0);</code></pre>


<p><a id='MCMC-1'></a></p>
<h2 id="mcmc">MCMC</h2>
<p>The following example is based on that published by Pooley et al. (2015) in the paper that introduces the model based proposal method. The observations data simulated by Pooley can be downloaded <a href="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/data/pooley.csv">here</a> and saved, e.g. to <code>path/to/data/</code>. Next, load the observations data using:</p>
<pre class="codehilite"><code>y = get_observations_from_file(&quot;path/to/data/pooley.csv&quot;)</code></pre>


<p>Now we can run an MCMC analysis based on the simulated datset:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_met_hastings_mcmc(model, y, [0.0025, 0.12]);
running MCMC...
 finished (sample Œº = [0.00342388, 0.11487])</code></pre>


<p>Visual inspection of the Markov chain using the traceplot is one way of assessing the convergence of the algorithm:</p>
<pre class="codehilite"><code>plot_parameter_trace(rs, 1);</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/jl_traceplot.png" alt="MCMC traceplots" height="220"/></p>
<p>The marginal distribution of parameters can be plotted by calling:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; plot_parameter_marginal(rs, 1)
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      (0.001,0.0015] ‚îÇ‚ñá 295                                   ‚îÇ
      (0.0015,0.002] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3378                    ‚îÇ
      (0.002,0.0025] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 6960    ‚îÇ
      (0.0025,0.003] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 7700 ‚îÇ
      (0.003,0.0035] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 7265   ‚îÇ
      (0.0035,0.004] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 5425           ‚îÇ
      (0.004,0.0045] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3148                     ‚îÇ
      (0.0045,0.005] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 2092                          ‚îÇ
      (0.005,0.0055] ‚îÇ‚ñá‚ñá‚ñá‚ñá‚ñá 1023                              ‚îÇ
      (0.0055,0.006] ‚îÇ‚ñá‚ñá‚ñá 675                                 ‚îÇ
      (0.006,0.0065] ‚îÇ‚ñá‚ñá 494                                  ‚îÇ
   Œ∏‚ÇÅ (0.0065,0.007] ‚îÇ‚ñá 271                                   ‚îÇ
      (0.007,0.0075] ‚îÇ 68                                     ‚îÇ
      (0.0075,0.008] ‚îÇ‚ñá 138                                   ‚îÇ
      (0.008,0.0085] ‚îÇ 76                                     ‚îÇ
      (0.0085,0.009] ‚îÇ 80                                     ‚îÇ
      (0.009,0.0095] ‚îÇ 111                                    ‚îÇ
       (0.0095,0.01] ‚îÇ‚ñá 273                                   ‚îÇ
       (0.01,0.0105] ‚îÇ‚ñá 195                                   ‚îÇ
      (0.0105,0.011] ‚îÇ‚ñá 133                                   ‚îÇ
      (0.011,0.0115] ‚îÇ 67                                     ‚îÇ
      (0.0115,0.012] ‚îÇ 77                                     ‚îÇ
      (0.012,0.0125] ‚îÇ 57                                     ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                      samples</code></pre>


<p>Plotting the data with third party packages such as PyPlot is simple:</p>
<pre class="codehilite"><code>using PyPlot
x = mcmc.samples[mcmc.adapt_period:size(mcmc.samples, 1), parameter]
plt[:hist](x, 30)

ylabel(&quot;density&quot;)</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/marginals.png" alt="MCMC traceplots" height="240"/></p>
<p>A pairwise representation can be produced by calling <code>plot_parameter_heatmap</code> (see below for an example).</p>
<p><a id='Autocorrelation-1'></a></p>
<h2 id="autocorrelation">Autocorrelation</h2>
<p>Autocorrelation can be used to help determine how well the algorithm mixed by using <code>compute_autocorrelation(rs.mcmc)</code>. The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:</p>
<p>
<script type="math/tex; mode=display">
R_l  = \frac{\textrm{E} [(X_i - \bar{X})(X_{i+l} - \bar{X})]}{\sigma^2}
</script>
</p>
<p>for any given lag <code>l</code>. The modified formula for multiple chains is given by:</p>
<p>
<script type="math/tex; mode=display">
R_{b,l} = \frac{\textrm{E} [ (X_i - \bar{X}_b) ( X_{i + l} - \bar{X}_b ) ]}{\sigma^2_b}
</script>
</p>
<p>
<script type="math/tex; mode=display">
\sigma^2_b = \textrm{E} [(X_i - \bar{X}_b)^2]
</script>
</p>
<p>NEED TO ADD image ...</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; ac = compute_autocorrelation(rs.mcmc)
ERROR: type MCMCResults has no field mcmc

julia&gt; p = plot_autocorrelation(ac)
ERROR: UndefVarError: ac not defined

julia&gt; print(p)
ERROR: UndefVarError: p not defined</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/sis-sim.png" alt="SIS simulation" height="180"/></p>
<p><a id='Convergence-diagnostics-1'></a></p>
<h2 id="convergence-diagnostics">Convergence diagnostics</h2>
<p><a id='Geweke-test-of-stationarity-1'></a></p>
<h3 id="geweke-test-of-stationarity">Geweke test of stationarity</h3>
<p>The Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain (see Geweke, 1992; Cowles, 1996). It is given by:</p>
<p>
<script type="math/tex; mode=display">
z = \frac{\bar{\theta}_{i, \alpha} - \bar{\theta}_{i, \beta}}{\sqrt{Var(\theta_{i, \alpha})+Var(\theta_{i, \beta})})}
</script>
</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; plot_geweke_series(rs)
ERROR: BoundsError: attempt to access 10√ó2 Array{Float64,2} at index [Base.Slice(Base.OneTo(10)), 3]</code></pre>


<p>The results of MCMC analyses can also be saved to file for analysis in the companion <a href="https://mjb3.github.io/Discuit/">R package</a>. In Julia, run:</p>
<pre class="codehilite"><code>print_mcmc_results(rs, &quot;path/to/mcmc/data/&quot;)</code></pre>


<p>Now, in R, run:</p>
<pre class="codehilite"><code>library(Discuit)
library(gridExtra)
rs = LoadMcmcResults(&quot;path/to/mcmc/data/&quot;)
tgt = c(0.003, 0.1)
grid.arrange(PlotGewekeSeries(rs), PlotParameterHeatmap(rs, 1, 2, tgt), nrow = 1)</code></pre>


<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/geweke_heatmap.png" alt="MCMC analysis" height="240"/></p>
<p><a id='Gelman-Rubin-convergence-diagnostic-1'></a></p>
<h3 id="gelman-rubin-convergence-diagnostic">Gelman-Rubin convergence diagnostic</h3>
<p>The Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance (Gelman et al, 1992, 2014). The <em>estimated scale reduction</em> statistic (sometimes referred to as <em>potential scale reduction factor</em>) is calculated for each parameter in the model.</p>
<p>Let $\bar{\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\theta$, within chain variance between chain variance respectively for $M$ Markov chains:</p>
<p>
<script type="math/tex; mode=display">
W = \frac{1}{M} \sum_{i = 1}^M \sigma^2_i
</script>
</p>
<p>
<script type="math/tex; mode=display">
B = \frac{N}{M - 1} \sum_{i = 1}^M (\hat{\theta}_i - \hat{\theta})^2
</script>
</p>
<p>The estimated scale reduction statistic is given by:</p>
<p>
<script type="math/tex; mode=display">
R = \sqrt{\frac{d + 3}{d + 1} \frac{N-1}{N} + (\frac{M+1}{MN} \frac{B}{W})}
</script>
</p>
<p>where the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_gelman_diagnostic(model, y, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);
running gelman diagnostic... (3 chains)
 chain 1 complete.
 chain 2 complete.
 chain 3 complete.
 vv w: [2.14888e-13, 4.18479e-7]
 vv b: [1.96555e-5, 30.3574]
 var.V: [4.94066e-324, NaN]
 finished (sample Œº = [0.00330828, 0.109512]).</code></pre>


<p><a id='Simulation-1'></a></p>
<h2 id="simulation">Simulation</h2>
<p>ADD SIM BLURB <code>generate_model("LOTKA", [79, 71])</code>.</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; xi = gillespie_sim(model, [0.5, 0.0025, 0.3]);
running simulation...
 finished (17520 events).</code></pre>


<p>The simulation can be visualised using <code>plot_trajectory(xi)</code>:</p>
<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/lotka_sim.png" alt="Lotka Volterra simulation" height="240"/></p>
<p><a id='Custom-MCMC-1'></a></p>
<h2 id="custom-mcmc">Custom MCMC</h2>
<p>Some situations...</p>
<p>First we generate a standard <code>SIR</code> model and set the <code>t0_index = 3</code>.</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; model = generate_model(&quot;SIR&quot;, [119, 1, 0]);

julia&gt; model.t0_index = 3;</code></pre>


<p>Next we define the "medium" prior used by O'Neill and Roberts, with some help from the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> package:</p>
<pre class="codehilite"><code class="language-julia-repl">  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
[?25l[2K[?25h Resolving package versions...
  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`
  [31c24e10] + Distributions v0.16.4
  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`
 [no changes]

julia&gt; using Distributions;

julia&gt; p1 = Gamma(10, 0.0001);

julia&gt; p2 = Gamma(10, 0.01);

julia&gt; function prior_density(parameters::Array{Float64, 1})
           return parameters[3] &lt; 0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0
       end
prior_density (generic function with 1 method)

julia&gt; model.prior_density = prior_density;</code></pre>


<p>The observation model is replaced with one that returns <code>log(1)</code> since we will only propose sequences consitent with the observed recoveries and $\pi(\xi | \theta)$ is evaluated automatically by Discuit):</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0
observation_model (generic function with 1 method)

julia&gt; model.observation_model = observation_model;</code></pre>


<p>Next we define an array <code>t</code> to contain the recovery times reported by O'Neill and Roberts and a simple <code>Observations</code> variable which consists of the maximum event time and an empty two dimensional array:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];

julia&gt; y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))
Observations([67.0], [140606421966832])</code></pre>


<p>We also need to define an initial state using the <code>generate_custom_x0</code> function using some parameter values and a vector of event times and corresponding event types, consistent with <code>t</code>:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; evt_tm = Float64[];

julia&gt; evt_tp = Int64[];

julia&gt; for i in 1:(length(t) - 1)# infections at arbitrary t &gt; t0
           push!(evt_tm, -4.0)
           push!(evt_tp, 1)
       end

julia&gt; for i in eachindex(t)     # recoveries
           push!(evt_tm, t[i])
           push!(evt_tp, 2)
       end

julia&gt; x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);</code></pre>


<p>The final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit).</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)
           t0 = xf_parameters.value[model.t0_index]
           ## move
           seq_f = deepcopy(xi.trajectory)
           # choose event and define new one
           evt_i = rand(1:length(xi.trajectory.time))
           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()
           evt_tp = xi.trajectory.event_type[evt_i]
           # remove old one
           splice!(seq_f.time, evt_i)
           splice!(seq_f.event_type, evt_i)
           # add new one
           if evt_tm &gt; seq_f.time[end]
               push!(seq_f.time, evt_tm)
               push!(seq_f.event_type, evt_tp)
           else
               for i in eachindex(seq_f.time)
                   if seq_f.time[i] &gt; evt_tm
                       insert!(seq_f.time, i, evt_tm)
                       insert!(seq_f.event_type, i, evt_tp)
                       break
                   end
               end
           end
           # compute ln g(x)
           prop_lk = 1.0
           ## evaluate full likelihood for trajectory proposal and return
           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)
       end # end of std proposal function
custom_proposal (generic function with 1 method)</code></pre>


<p>We can now run the MCMC analysis:</p>
<pre class="codehilite"><code class="language-julia-repl">julia&gt; rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);
running custom MCMC...
 finished (sample Œº = [0.000993775, 0.104761, -3.18788]).</code></pre>


<p>Need to add commentary:</p>
<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/cmcmc_trace.png" alt="SIR traceplots" height="220"/></p>
<p><img src="https://raw.githubusercontent.com/mjb3/Discuit.jl/master/docs/img/cmcmc_geweke_hm.png" alt="SIR traceplots" height="220"/></p>
<ul>
<li>link to <a href="../manual/#Discuit.set_random_seed"><code>set_random_seed(seed::Int64)</code></a></li>
</ul>
<p><a id='References-1'></a></p>
<h2 id="references">References</h2>
<p><html>
<head>
<script type="text/javascript" src="https://cdn.rawgit.com/pcooksey/bibtex-js/ef59e62c/src/bibtex_js.js"></script>
</head>
<body>
<textarea id="bibtex_input" style="display:none;">
@article{gillespie_exact_1977,
    title = {Exact stochastic simulation of coupled chemical reactions},
    volume = {81},
    issn = {0022-3654, 1541-5740},
    url = {http://pubs.acs.org/doi/abs/10.1021/j100540a008},
    doi = {10.1021/j100540a008},
    language = {en},
    number = {25},
    urldate = {2017-02-18},
    journal = {The Journal of Physical Chemistry},
    author = {Gillespie, Daniel T.},
    month = dec,
    year = {1977},
    pages = {2340--2361}
}</p>
<p>@incollection{geweke_evaluating_1992,
    title = {Evaluating the {Accuracy} of {Sampling}-{Based} {Approaches} to the {Calculation} of {Posterior} {Moments}},
    abstract = {Data augmentation and Gibbs sampling are two closely related, sampling-based approaches to the calculation of posterior moments. The fact that each produces a sample whose constituents are neither independent nor identically distributed complicates the assessment of convergence and numerical accuracy of the approximations to the expected value of functions of interest under the posterior. In this paper methods from spectral analysis are used to evaluate numerical accuracy formally and construct diagnostics for convergence. These methods are illustrated in the normal linear model with informative priors, and in the Tobit-censored regression model.},
    booktitle = {{IN} {BAYESIAN} {STATISTICS}},
    publisher = {University Press},
    author = {Geweke, John},
    year = {1992},
    pages = {169--193}
}</p>
<p>@article{cowles_markov_1996,
    title = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}: {A} {Comparative} {Review}},
    volume = {91},
    issn = {01621459},
    shorttitle = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}},
    url = {http://www.jstor.org/stable/2291683},
    doi = {10.2307/2291683},
    number = {434},
    urldate = {2018-03-20},
    journal = {Journal of the American Statistical Association},
    author = {Cowles, Mary Kathryn and Carlin, Bradley P.},
    month = jun,
    year = {1996},
    pages = {883}
}</p>
<p>@article{gelman_inference_1992,
    title = {Inference from iterative simulation using multiple sequences},
    journal = {Statistical science},
    author = {Gelman, Andrew and Rubin, Donald B.},
    year = {1992},
    pages = {457--472}
}
@book{gelman_bayesian_2014,
    title = {Bayesian data analysis},
    isbn = {978-1-4398-9820-8 978-1-4398-4096-2},
    language = {English},
    urldate = {2018-03-18},
    author = {Gelman, Andrew and Carlin, John B and Stern, Hal Steven and Dunson, David B and Vehtari, Aki and Rubin, Donald B},
    year = {2014},
    note = {OCLC: 909477393}
}
</textarea>
<div id="bibtex_display"></div>
</body>
</html></p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../assets/mathjaxhelper.js"></script>
        <script src="https://cdn.rawgit.com/pcooksey/bibtex-js/ef59e62c/src/bibtex_js.js"></script>
        <script src="../search/require.js"></script>
        <script src="../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
