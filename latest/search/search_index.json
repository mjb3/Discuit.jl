{
    "docs": [
        {
            "location": "/", 
            "text": "Discuit.jl\n\n\nFast parameter inference for discrete state space continuous time (DSSCT) models in Julia.\n\n\n\n\nPlease note that this package is still in development.\n\n\n\n\nDiscuit is a package for Bayesian inference in Discrete state space continuous time (DSSCT) models. DSSCT models, sometimes referred to as compartmental models, are used to represent systems where individuals are assumed, usually as a simplifying abstraction, to move between discrete states. They are a well established research tool in fields including physics, chemistry and ecology. Their use in scientific research typically involves the challenge of comparing \u2018noisy\u2019 experimental or observational data to the unobserved (i.e. latent) underlying processes described by the model. Bayes\u2019 theorem provides a convenient framework for dealing with uncertainty in the data. The Bayesian framework also provide a natural, methodologically consistent way of incorporating existing scientific knowledge of the system; the prior distribution of the model parameters\n\n\nThe augmented data Markov chain Monte Carlo (MCMC) methods implemented in Discuit work by introducing a latent variable $\\xi$ which represents the sequence of events in a single realisation of the model:\n\n\n\n\n\n\\pi(\\theta|y) = \\pi(y|\\xi) \\pi(\\xi|\\theta) \\pi(\\theta)\n\n\n\n\n\nSee \nIntroduction to MCMC\n for a basic introduction to MCMC and \nIntroduction to Monte Carlo methods\n for an overview of random sampling generally. Two algorithms for making proposals to the augmented data space are shipped with the package, with user defined implementations made possible via an alternative \ncustom MCMC\n framework. Automated tools for analysis and convergence diagnostics include autocorrelation, the Geweke test of stationarity and the Gelman-Rubin diagnostic for multiple Markov chains (a convenient way to run analyses where more than one processor thread is available for use). \nSimulation\n via the Gillespie direct method provides a source of simulated observations data for evaluation and validation of the core inference functionality.\n\n\nSee the \nDiscuit.jl models\n section for an introduction to the aforementioned functionality and the \nDiscuit.jl manual\n for a description of data types and functions. See the \nDiscuit in R\n package documentation for a description of the equivalent functionality in that package.\n\n\n\n\nPackage features\n\n\n#\n\n\nDiscuit\n \n \nModule\n.\n\n\nDiscuit is a package for:\n\n\n\n\nCustomisable finite adaptive MCMC algorithm for fast parameter inference.\n\n\nPooley model based proposal (MBP) method for improved mixing.\n\n\nSimulation via the Gillespie direct method.\n\n\nAutomated tools for convergence diagnosis and analysis.\n\n\nDeveloped for Julia \n1.0\n.\n\n\nAuthor: Martin Burke (martin.burke@bioss.ac.uk)\n\n\nDate: 2018-08-22\n\n\n\n\nsource\n\n\n\n\nInstallation\n\n\nThe package can be installed by typing \n]\n in the REPL to enter the Pkg mode and running:\n\n\npkg\n add https://github.com/mjb3/Discuit.jl\n\n\n\n\n\n\nGetting started\n\n\nThe following code initialises a \nDiscuitModel\n and runs a simulation, storing the results in \nx\n.\n\n\njulia\n using Discuit;\n\n\njulia\n model = generate_model(\nSIS\n, [100,1]);\n\njulia\n x = gillespie_sim(model, [0.003, 0.1]);\nrunning simulation...\n finished (1037 events).\n\n\n\n\nWe can now run an MCMC analysis using observations data from \nx\n:\n\n\njulia\n s = run_met_hastings_mcmc(model, x.observations, [0.0025, 0.12]);\nrunning MCMC...\n finished (sample \u03bc = [0.00360464, 0.129626])\n\n\n\n\n\n\nFurther usage\n\n\nMore examples can be found in the section \nDiscuit.jl examples\n, including enough code to get up and running with convergence diagnostics and customised models. A more detailed guide to the pre defined models is available in the \nDiscuit.jl models\n section. Further information regarding the packages other functionality can be found in the \nDiscuit.jl manual\n.\n\n\n\n\nTutorials\n\n\n\n\nIntroduction to Monte Carlo methods\n: a beginner's guide in Python.\n\n\nA basic \nIntroduction to MCMC\n methods in Python.\n\n\nDiscuit.jl examples\n: an introduction to MCMC and simulation in \nDiscuit.jl\n for Julia.\n\n\nSee the \nDiscuit for R package documentation\n for R examples.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#discuitjl", 
            "text": "Fast parameter inference for discrete state space continuous time (DSSCT) models in Julia.   Please note that this package is still in development.   Discuit is a package for Bayesian inference in Discrete state space continuous time (DSSCT) models. DSSCT models, sometimes referred to as compartmental models, are used to represent systems where individuals are assumed, usually as a simplifying abstraction, to move between discrete states. They are a well established research tool in fields including physics, chemistry and ecology. Their use in scientific research typically involves the challenge of comparing \u2018noisy\u2019 experimental or observational data to the unobserved (i.e. latent) underlying processes described by the model. Bayes\u2019 theorem provides a convenient framework for dealing with uncertainty in the data. The Bayesian framework also provide a natural, methodologically consistent way of incorporating existing scientific knowledge of the system; the prior distribution of the model parameters  The augmented data Markov chain Monte Carlo (MCMC) methods implemented in Discuit work by introducing a latent variable $\\xi$ which represents the sequence of events in a single realisation of the model:   \n\\pi(\\theta|y) = \\pi(y|\\xi) \\pi(\\xi|\\theta) \\pi(\\theta)   See  Introduction to MCMC  for a basic introduction to MCMC and  Introduction to Monte Carlo methods  for an overview of random sampling generally. Two algorithms for making proposals to the augmented data space are shipped with the package, with user defined implementations made possible via an alternative  custom MCMC  framework. Automated tools for analysis and convergence diagnostics include autocorrelation, the Geweke test of stationarity and the Gelman-Rubin diagnostic for multiple Markov chains (a convenient way to run analyses where more than one processor thread is available for use).  Simulation  via the Gillespie direct method provides a source of simulated observations data for evaluation and validation of the core inference functionality.  See the  Discuit.jl models  section for an introduction to the aforementioned functionality and the  Discuit.jl manual  for a description of data types and functions. See the  Discuit in R  package documentation for a description of the equivalent functionality in that package.", 
            "title": "Discuit.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "#  Discuit     Module .  Discuit is a package for:   Customisable finite adaptive MCMC algorithm for fast parameter inference.  Pooley model based proposal (MBP) method for improved mixing.  Simulation via the Gillespie direct method.  Automated tools for convergence diagnosis and analysis.  Developed for Julia  1.0 .  Author: Martin Burke (martin.burke@bioss.ac.uk)  Date: 2018-08-22   source", 
            "title": "Package features"
        }, 
        {
            "location": "/#installation", 
            "text": "The package can be installed by typing  ]  in the REPL to enter the Pkg mode and running:  pkg  add https://github.com/mjb3/Discuit.jl", 
            "title": "Installation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "The following code initialises a  DiscuitModel  and runs a simulation, storing the results in  x .  julia  using Discuit;\n\n\njulia  model = generate_model( SIS , [100,1]);\n\njulia  x = gillespie_sim(model, [0.003, 0.1]);\nrunning simulation...\n finished (1037 events).  We can now run an MCMC analysis using observations data from  x :  julia  s = run_met_hastings_mcmc(model, x.observations, [0.0025, 0.12]);\nrunning MCMC...\n finished (sample \u03bc = [0.00360464, 0.129626])", 
            "title": "Getting started"
        }, 
        {
            "location": "/#further-usage", 
            "text": "More examples can be found in the section  Discuit.jl examples , including enough code to get up and running with convergence diagnostics and customised models. A more detailed guide to the pre defined models is available in the  Discuit.jl models  section. Further information regarding the packages other functionality can be found in the  Discuit.jl manual .", 
            "title": "Further usage"
        }, 
        {
            "location": "/#tutorials", 
            "text": "Introduction to Monte Carlo methods : a beginner's guide in Python.  A basic  Introduction to MCMC  methods in Python.  Discuit.jl examples : an introduction to MCMC and simulation in  Discuit.jl  for Julia.  See the  Discuit for R package documentation  for R examples.", 
            "title": "Tutorials"
        }, 
        {
            "location": "/examples/", 
            "text": "Discuit.jl examples\n\n\nThe following examples provide a flavour of package's core functionality. See the \nDiscuit.jl manual\n for a description of the data types and functions in Discuit, and \nDiscuit.jl models\n for a description of the predefined models available in the package.\n\n\n\n\nDefining a model\n\n\nDiscuitModel\ns can be created automatically using helper functions or manually by specifying each component. For example the model we are about to create could be generated automatically using \ngenerate_model(\"SIS\", [100,1])\n. However constructing it manually is a helpful exercise for getting to know the package. See \nDiscuit.jl models\n for further details of the \ngenerate_model\n function. We start by examining \nDiscuitModel\n in the package documentation:\n\n\njulia\n using Discuit;\n\n\n\n\nNext we define a rate function equivalent to that of the basic Kermack-McKendrick \nSIS\n (and \nSIR\n) model. The event rates for infection and recovery events respectively are given by:\n\n\n\n\n\nr_1 = \\theta_1 SI\n\n\n\n\n\n\n\n\nr_2 = \\theta_2 I\n\n\n\n\n\nThe code is correspondingly straightforward:\n\n\njulia\n function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n           output[1] = parameters[1] * population[1] * population[2]\n           output[2] = parameters[2] * population[2]\n       end\nsis_rf (generic function with 1 method)\n\n\n\n\nNote that the correct signature must be used in the implementation for it to be compatible with the package. Next we define a simple observation function, again with the correct signature:\n\n\njulia\n obs_fn(population::Array{Int64, 1}) = population\nobs_fn (generic function with 1 method)\n\n\n\n\nThe default prior distribution is flat and improper and is equivalent to:\n\n\njulia\n function weak_prior(parameters::Array{Float64, 1})\n           parameters[1] \n 0.0 || return 0.0\n           parameters[2] \n 0.0 || return 0.0\n           return 1.0\n       end\nweak_prior (generic function with 1 method)\n\n\n\n\nFinally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation \n2\n:\n\n\njulia\n function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})\n           obs_err = 2\n           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))\n           tmp2 = 2 * obs_err * obs_err\n           obs_diff = y[2] - population[2]\n           return tmp1 - ((obs_diff * obs_diff) / tmp2)\n       end\nsi_gaussian (generic function with 1 method)\n\n\n\n\nWe can now define a model. The three parameters declared inline are the transition matrix; an optional index for the t0 parameter (ignore for now); and the initial condition which represents the state of the population at the origin of each trajectory:\n\n\njulia\n model = DiscuitModel(\nSIS\n, [100, 1], sis_rf, [-1 1; 1 -1], obs_fn, weak_prior, si_gaussian, 0);\n\n\n\n\n\n\nMCMC\n\n\nThe following example is based on that published by Pooley et al. (2015) in the paper that introduces the model based proposal method. The observations data simulated by Pooley can be downloaded \nhere\n and saved, e.g. to \npath/to/data/\n. Next, load the observations data using:\n\n\ny = get_observations_from_file(\npath/to/data/pooley.csv\n)\n\n\n\n\nNow we can run an MCMC analysis based on the simulated datset:\n\n\njulia\n rs = run_met_hastings_mcmc(model, y, [0.0025, 0.12]);\nrunning MCMC...\n finished (sample \u03bc = [0.00342388, 0.11487])\n\n\n\n\nVisual inspection of the Markov chain using the traceplot is one way of assessing the convergence of the algorithm:\n\n\nplot_parameter_trace(rs, 1);\n\n\n\n\n\n\nThe marginal distribution of parameters can be plotted by calling:\n\n\njulia\n plot_parameter_marginal(rs, 1)\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      (0.001,0.0015] \u2502\u2587 295                                   \u2502\n      (0.0015,0.002] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 3378                    \u2502\n      (0.002,0.0025] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 6960    \u2502\n      (0.0025,0.003] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 7700 \u2502\n      (0.003,0.0035] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 7265   \u2502\n      (0.0035,0.004] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 5425           \u2502\n      (0.004,0.0045] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 3148                     \u2502\n      (0.0045,0.005] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 2092                          \u2502\n      (0.005,0.0055] \u2502\u2587\u2587\u2587\u2587\u2587 1023                              \u2502\n      (0.0055,0.006] \u2502\u2587\u2587\u2587 675                                 \u2502\n      (0.006,0.0065] \u2502\u2587\u2587 494                                  \u2502\n   \u03b8\u2081 (0.0065,0.007] \u2502\u2587 271                                   \u2502\n      (0.007,0.0075] \u2502 68                                     \u2502\n      (0.0075,0.008] \u2502\u2587 138                                   \u2502\n      (0.008,0.0085] \u2502 76                                     \u2502\n      (0.0085,0.009] \u2502 80                                     \u2502\n      (0.009,0.0095] \u2502 111                                    \u2502\n       (0.0095,0.01] \u2502\u2587 273                                   \u2502\n       (0.01,0.0105] \u2502\u2587 195                                   \u2502\n      (0.0105,0.011] \u2502\u2587 133                                   \u2502\n      (0.011,0.0115] \u2502 67                                     \u2502\n      (0.0115,0.012] \u2502 77                                     \u2502\n      (0.012,0.0125] \u2502 57                                     \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      samples\n\n\n\n\nPlotting the data with third party packages such as PyPlot is simple:\n\n\nusing PyPlot\nx = mcmc.samples[mcmc.adapt_period:size(mcmc.samples, 1), parameter]\nplt[:hist](x, 30)\n\nylabel(\ndensity\n)\n\n\n\n\n\n\nA pairwise representation can be produced by calling \nplot_parameter_heatmap\n (see below for an example).\n\n\n\n\nAutocorrelation\n\n\nAutocorrelation can be used to help determine how well the algorithm mixed by using \ncompute_autocorrelation\n. The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:\n\n\n\n\n\nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}\n\n\n\n\n\nfor any given lag \nl\n. The modified formula for multiple chains is given by:\n\n\n\n\n\nR_{b,l} = \\frac{\\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]}{\\sigma^2_b}\n\n\n\n\n\n\n\n\n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]\n\n\n\n\n\njulia\n ac = compute_autocorrelation(rs);\nmu = [0.00342388, 0.11487]\n\njulia\n plot_autocorrelation(ac)\n                   \u03b8 autocorrelation\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     1 \u2502\u28a7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2808\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2818\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2819\u2877\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2818\u288e\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2811\u28cd\u28a6\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2833\u28dd\u2826\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n   R   \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u282e\u28d7\u28e4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281b\u2897\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u2897\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u28e7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u283b\u2866\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u2897\u2866\u28c4\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2819\u281b\u2833\u2836\u28a6\u28e4\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n     0 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281b\u28b7\u28e6\u28c0\u28c0\u28c0\u28c0\u28c0\u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       0                                     2000\n                          lag\n\n\n\n\nNote that the latter formulation (for multiple chains) is likely to give a more accurate indication of algorithm performance. The code is virtually identical. Just replace \nrs\n with the results of a call to \nrun_gelman_diagnostic\n.\n\n\n\n\nConvergence diagnostics\n\n\nThe goal of an MCMC analysis is to construct a Markov chain that has the target distribution as its equilibrium distribution, i.e. it has converged. However assessing whether this is the case can be challenging since we do not know the target distribution. Visual inspection of the Markov chain may not be sufficient to diagnose convergence, particularly where the target distribution has local optima. Automated convergence diagnostics are therefore integrated closely with the MCMC functionality in Discuit; the Geweke test for single chains and the Gelman-Rubin for multiple chains. Just like autocorrelation, the latter, provided that the chains have been initialised with over dispersed parameters (with respect to the target distribution), provides a more reliable indication of algorithm performance (in this case, convergence).\n\n\n\n\nGeweke test of stationarity\n\n\nThe Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain (see Geweke, 1992; Cowles, 1996). It is given by:\n\n\n\n\n\nz = \\frac{\\bar{\\theta}_{i, \\alpha} - \\bar{\\theta}_{i, \\beta}}{\\sqrt{Var(\\theta_{i, \\alpha})+Var(\\theta_{i, \\beta})})}\n\n\n\n\n\nGeweke statistics are computed automatically for analyses run in Discuit and can be accessed directly (i.e. \nrs.geweke\n) or else inspected using one of the built in tools, e.g:\n\n\njulia\n plot_geweke_series(rs)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      2 \u2502\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2806\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n   z    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2809\u2809\u2809\u2809\u2849\u2809\u2809\u2809\u284d\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u280b\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u284d\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2801\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2801\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n     -1 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        0                                    20000\n\n\n\n\nNote that the results of MCMC analyses, including Geweke statistics, can be saved to file for analysis in the companion \nR package\n. In Julia, run:\n\n\nprint_mcmc_results(rs, \npath/to/mcmc/data/\n)\n\n\n\n\nNow, in R, run:\n\n\nlibrary(Discuit)\nlibrary(gridExtra)\nrs = LoadMcmcResults(\npath/to/mcmc/data/\n)\ntgt = c(0.003, 0.1)\ngrid.arrange(PlotGewekeSeries(rs), PlotParameterHeatmap(rs, 1, 2, tgt), nrow = 1)\n\n\n\n\n\n\n\n\nGelman-Rubin convergence diagnostic\n\n\nThe Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance (Gelman et al, 1992, 2014). The \nestimated scale reduction\n statistic (sometimes referred to as \npotential scale reduction factor\n) is calculated for each parameter in the model.\n\n\nLet $\\bar{\\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\\theta$, within chain variance between chain variance respectively for $M$ Markov chains:\n\n\n\n\n\nW = \\frac{1}{M} \\sum_{i = 1}^M \\sigma^2_i\n\n\n\n\n\n\n\n\nB = \\frac{N}{M - 1} \\sum_{i = 1}^M (\\hat{\\theta}_i - \\hat{\\theta})^2\n\n\n\n\n\nThe estimated scale reduction statistic is given by:\n\n\n\n\n\nR = \\sqrt{\\frac{d + 3}{d + 1} \\frac{N-1}{N} + (\\frac{M+1}{MN} \\frac{B}{W})}\n\n\n\n\n\nwhere the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.\n\n\njulia\n rs = run_gelman_diagnostic(model, y, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);\nrunning gelman diagnostic... (3 chains)\n chain 1 complete.\n chain 2 complete.\n chain 3 complete.\n vv w: [2.14888e-13, 4.18479e-7]\n vv b: [1.96555e-5, 30.3574]\n var.V: [4.94066e-324, NaN]\n finished (sample \u03bc = [0.00330828, 0.109512]).\n\n\n\n\n\n\nSimulation\n\n\nThe main purpose of the simulation functionality included in Discuit is to provide a source of simulated observations data for evaluation and validation of the MCMC functionality. However simulation can also be an interesting way to explore and better understand the dynamics of the model.\n\n\nTo produce the Lotka-Volterra example given in the paper use:\n\n\njulia\n model = generate_model(\nLOTKA\n, [79, 71]);\n\njulia\n xi = gillespie_sim(model, [0.5, 0.0025, 0.3]);\nrunning simulation...\n finished (17520 events).\n\njulia\n plot_trajectory(xi)\n                                PN simulation\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              500 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 P\n                  \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 N\n                  \u2502\u2800\u2800\u2800\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2800\u28b8\u28a7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2800\u28b8\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2880\u28b8\u28b8\u2840\u2800\u2800\u2800\u2800\u2800\u28b0\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u2807\u2847\u2800\u2800\u2800\u2800\u28f7\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u28b8\u284f\u2800\u2847\u2800\u2800\u2800\u2800\u2800\u285f\u28b9\u2840\u2800\u2800\u2800\u2800\u2800\u28f6\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u28c7\u2800\u2800\u2800\u28b0\u283f\u2844\u2800\u2800\u2502\n   population     \u2502\u2800\u285e\u28e7\u2800\u28c7\u2800\u2800\u2800\u2800\u28a0\u2807\u2800\u2847\u2800\u2800\u2800\u2800\u28b8\u2819\u2847\u2800\u2800\u28b8\u28b6\u28f4\u2844\u2800\u2800\u28a0\u28fe\u2800\u28b8\u2800\u2800\u2800\u28f8\u2800\u2847\u2800\u2800\u2502\n                  \u2502\u2800\u2847\u28ff\u2800\u28b8\u2800\u2800\u2800\u2800\u28ff\u2840\u2800\u28b3\u2800\u2800\u2800\u2880\u287c\u2800\u28b3\u2800\u2800\u284f\u2808\u2801\u28b3\u2800\u2800\u28b8\u28ff\u2844\u2838\u2844\u2800\u28f0\u28fb\u2800\u28b9\u2800\u2800\u2502\n                  \u2502\u2800\u28c7\u28ff\u2800\u2808\u28e7\u2800\u2800\u28f8\u28fb\u28e7\u2800\u28b8\u2844\u2800\u2800\u28f8\u28a7\u2800\u28b8\u2844\u28a0\u2847\u2800\u2800\u2818\u2847\u2800\u285e\u2847\u2847\u2800\u28c7\u2800\u284f\u284f\u2847\u2808\u2847\u2800\u2502\n                  \u2502\u28b8\u28b9\u28b8\u2800\u2800\u2818\u28c7\u2880\u28ef\u2847\u28b8\u2840\u2800\u28b3\u28e0\u28b6\u281f\u2838\u2844\u2800\u28bf\u28fe\u28b7\u2880\u2800\u2800\u28a7\u2800\u28f7\u2803\u2847\u2800\u28b8\u2880\u28f7\u2803\u2847\u2800\u28b9\u2840\u2502\n                  \u2502\u28b8\u28b8\u2808\u2847\u2800\u2800\u2838\u28fe\u281f\u2801\u2808\u28c7\u2800\u2800\u28bb\u285f\u2800\u2800\u28a7\u2800\u2880\u2847\u2818\u283b\u28e6\u2800\u2818\u28be\u287f\u2800\u28a7\u2800\u2818\u28fe\u287e\u2800\u28a7\u2800\u2800\u28b3\u2502\n                  \u2502\u28cf\u285e\u2800\u28c7\u2800\u2800\u2880\u285f\u2800\u2800\u2800\u28b9\u2840\u28b0\u280b\u2800\u2800\u2800\u2818\u2846\u287e\u2800\u2800\u2800\u2838\u28c6\u28f4\u280f\u2800\u2800\u28b8\u2800\u2880\u287f\u2803\u2800\u2838\u2844\u2880\u28f0\u2502\n                  \u2502\u2808\u2800\u2800\u2839\u2874\u281f\u281e\u2800\u2800\u2800\u2800\u2800\u2833\u280f\u2800\u2800\u2800\u2800\u2800\u281b\u2803\u2800\u2800\u2800\u2800\u2808\u2801\u2800\u2800\u2800\u2808\u28a7\u285f\u2800\u2800\u2800\u2800\u2833\u281e\u2801\u2502\n                0 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  0                                      100\n                                    time\n\n\n\n\nThe maximum time of the simulation and number of observations to draw can also be specified, e.g. \ngenerate_model(\"LOTKA\", [79, 71], 100.0, 10)\n.\n\n\n\n\nCustom MCMC\n\n\nIn addition to the two proposal algorithms included with the packages by default, Discuit allows for users to develop their own algorithms for data augmented MCMC via the alternative custom MCMC framework, while still taking advantage of features including automated, finite adaptive multivariate \u03b8 proposals.\n\n\nIn some cases may wish to simply tweak the proposal algorithms included in the source code repositories for minor performance gains in certain models, but the custom MCMC framework can also be useful in cases where the augmented data aspects of the model have specific or complex constraints, such as the next example which is based on an analysis of a smallpox outbreak within a closed community in Abakaliki, Nigeria by O'Neill and Roberts (ADD CITATION). First we generate a standard \nSIR\n model and set the \nt0_index = 3\n:\n\n\njulia\n model = generate_model(\nSIR\n, [119, 1, 0]);\n\njulia\n model.t0_index = 3;\n\n\n\n\nNext we define the \"medium\" prior used by O'Neill and Roberts, with some help from the \nDistributions.jl\n package:\n\n\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n\u001b[?25l\u001b[2K\u001b[?25h Resolving package versions...\n  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`\n  [31c24e10] + Distributions v0.16.4\n  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`\n [no changes]\n\njulia\n using Distributions;\n\njulia\n p1 = Gamma(10, 0.0001);\n\njulia\n p2 = Gamma(10, 0.01);\n\njulia\n function prior_density(parameters::Array{Float64, 1})\n           return parameters[3] \n 0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0\n       end\nprior_density (generic function with 1 method)\n\njulia\n model.prior_density = prior_density;\n\n\n\n\nThe observation model is replaced with one that returns \nlog(1)\n since we will only propose sequences consitent with the observed recoveries and $\\pi(\\xi | \\theta)$ is evaluated automatically by Discuit):\n\n\njulia\n observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0\nobservation_model (generic function with 1 method)\n\njulia\n model.observation_model = observation_model;\n\n\n\n\nNext we define an array \nt\n to contain the recovery times reported by O'Neill and Roberts and a simple \nObservations\n variable which consists of the maximum event time and an empty two dimensional array:\n\n\njulia\n t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];\n\njulia\n y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))\nObservations([67.0], [140682978773872])\n\n\n\n\nWe also need to define an initial state using the \ngenerate_custom_x0\n function using some parameter values and a vector of event times and corresponding event types, consistent with \nt\n:\n\n\njulia\n evt_tm = Float64[];\n\njulia\n evt_tp = Int64[];\n\njulia\n for i in 1:(length(t) - 1)# infections at arbitrary t \n t0\n           push!(evt_tm, -4.0)\n           push!(evt_tp, 1)\n       end\n\njulia\n for i in eachindex(t)     # recoveries\n           push!(evt_tm, t[i])\n           push!(evt_tp, 2)\n       end\n\njulia\n x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);\n\n\n\n\nThe final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit). Since it is assumed that the total number of events is known we can construct an algorithm that simply changes the time of an event in the trajectory. Events are chosen and new times drawn from uniform distributions ensuring that:\n\n\n\n\n\ng(X_{f \\rightarrow i}) = g(X_{i \\rightarrow f})\n\n\n\n\n\nsuch that the terms cancel in the Metropolis-Hastings acceptance equation. Some additional information is available regarding the times of recoveries; they are known to within a day. We therefore propose new recovery event times such that they remain within the time frame of a single time unit, which correspond to days in this model:\n\n\njulia\n function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)\n           t0 = xf_parameters.value[model.t0_index]\n           ## move\n           seq_f = deepcopy(xi.trajectory)\n           # choose event and define new one\n           evt_i = rand(1:length(xi.trajectory.time))\n           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()\n           evt_tp = xi.trajectory.event_type[evt_i]\n           # remove old one\n           splice!(seq_f.time, evt_i)\n           splice!(seq_f.event_type, evt_i)\n           # add new one\n           if evt_tm \n seq_f.time[end]\n               push!(seq_f.time, evt_tm)\n               push!(seq_f.event_type, evt_tp)\n           else\n               for i in eachindex(seq_f.time)\n                   if seq_f.time[i] \n evt_tm\n                       insert!(seq_f.time, i, evt_tm)\n                       insert!(seq_f.event_type, i, evt_tp)\n                       break\n                   end\n               end\n           end\n           # compute ln g(x)\n           prop_lk = 1.0\n           ## evaluate full likelihood for trajectory proposal and return\n           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)\n       end # end of std proposal function\ncustom_proposal (generic function with 1 method)\n\n\n\n\nWe can now run the MCMC analysis:\n\n\njulia\n rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);\nrunning custom MCMC...\n finished (sample \u03bc = [0.000993775, 0.104761, -3.18788]).\n\n\n\n\nThe output from the custom MCMC functionality is in the same format as the those produced using the core functions and thus be analysed in the same way. In this case the results were saved to file and analysed in R, in the manner described above:\n\n\n\n\nThe traceplots indicate good mixing and the results are fairly similar to that obtained by O'Neill and Roberts given the differences in the models used.\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n@article{gillespie_exact_1977,\n    title = {Exact stochastic simulation of coupled chemical reactions},\n    volume = {81},\n    issn = {0022-3654, 1541-5740},\n    url = {http://pubs.acs.org/doi/abs/10.1021/j100540a008},\n    doi = {10.1021/j100540a008},\n    language = {en},\n    number = {25},\n    urldate = {2017-02-18},\n    journal = {The Journal of Physical Chemistry},\n    author = {Gillespie, Daniel T.},\n    month = dec,\n    year = {1977},\n    pages = {2340--2361}\n}\n\n\n@incollection{geweke_evaluating_1992,\n    title = {Evaluating the {Accuracy} of {Sampling}-{Based} {Approaches} to the {Calculation} of {Posterior} {Moments}},\n    abstract = {Data augmentation and Gibbs sampling are two closely related, sampling-based approaches to the calculation of posterior moments. The fact that each produces a sample whose constituents are neither independent nor identically distributed complicates the assessment of convergence and numerical accuracy of the approximations to the expected value of functions of interest under the posterior. In this paper methods from spectral analysis are used to evaluate numerical accuracy formally and construct diagnostics for convergence. These methods are illustrated in the normal linear model with informative priors, and in the Tobit-censored regression model.},\n    booktitle = {{IN} {BAYESIAN} {STATISTICS}},\n    publisher = {University Press},\n    author = {Geweke, John},\n    year = {1992},\n    pages = {169--193}\n}\n\n\n@article{cowles_markov_1996,\n    title = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}: {A} {Comparative} {Review}},\n    volume = {91},\n    issn = {01621459},\n    shorttitle = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}},\n    url = {http://www.jstor.org/stable/2291683},\n    doi = {10.2307/2291683},\n    number = {434},\n    urldate = {2018-03-20},\n    journal = {Journal of the American Statistical Association},\n    author = {Cowles, Mary Kathryn and Carlin, Bradley P.},\n    month = jun,\n    year = {1996},\n    pages = {883}\n}\n\n\n@article{gelman_inference_1992,\n    title = {Inference from iterative simulation using multiple sequences},\n    journal = {Statistical science},\n    author = {Gelman, Andrew and Rubin, Donald B.},\n    year = {1992},\n    pages = {457--472}\n}\n@book{gelman_bayesian_2014,\n    title = {Bayesian data analysis},\n    isbn = {978-1-4398-9820-8 978-1-4398-4096-2},\n    language = {English},\n    urldate = {2018-03-18},\n    author = {Gelman, Andrew and Carlin, John B and Stern, Hal Steven and Dunson, David B and Vehtari, Aki and Rubin, Donald B},\n    year = {2014},\n    note = {OCLC: 909477393}\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#discuitjl-examples", 
            "text": "The following examples provide a flavour of package's core functionality. See the  Discuit.jl manual  for a description of the data types and functions in Discuit, and  Discuit.jl models  for a description of the predefined models available in the package.", 
            "title": "Discuit.jl examples"
        }, 
        {
            "location": "/examples/#defining-a-model", 
            "text": "DiscuitModel s can be created automatically using helper functions or manually by specifying each component. For example the model we are about to create could be generated automatically using  generate_model(\"SIS\", [100,1]) . However constructing it manually is a helpful exercise for getting to know the package. See  Discuit.jl models  for further details of the  generate_model  function. We start by examining  DiscuitModel  in the package documentation:  julia  using Discuit;  Next we define a rate function equivalent to that of the basic Kermack-McKendrick  SIS  (and  SIR ) model. The event rates for infection and recovery events respectively are given by:   \nr_1 = \\theta_1 SI    \nr_2 = \\theta_2 I   The code is correspondingly straightforward:  julia  function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n           output[1] = parameters[1] * population[1] * population[2]\n           output[2] = parameters[2] * population[2]\n       end\nsis_rf (generic function with 1 method)  Note that the correct signature must be used in the implementation for it to be compatible with the package. Next we define a simple observation function, again with the correct signature:  julia  obs_fn(population::Array{Int64, 1}) = population\nobs_fn (generic function with 1 method)  The default prior distribution is flat and improper and is equivalent to:  julia  function weak_prior(parameters::Array{Float64, 1})\n           parameters[1]   0.0 || return 0.0\n           parameters[2]   0.0 || return 0.0\n           return 1.0\n       end\nweak_prior (generic function with 1 method)  Finally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation  2 :  julia  function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})\n           obs_err = 2\n           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))\n           tmp2 = 2 * obs_err * obs_err\n           obs_diff = y[2] - population[2]\n           return tmp1 - ((obs_diff * obs_diff) / tmp2)\n       end\nsi_gaussian (generic function with 1 method)  We can now define a model. The three parameters declared inline are the transition matrix; an optional index for the t0 parameter (ignore for now); and the initial condition which represents the state of the population at the origin of each trajectory:  julia  model = DiscuitModel( SIS , [100, 1], sis_rf, [-1 1; 1 -1], obs_fn, weak_prior, si_gaussian, 0);", 
            "title": "Defining a model"
        }, 
        {
            "location": "/examples/#mcmc", 
            "text": "The following example is based on that published by Pooley et al. (2015) in the paper that introduces the model based proposal method. The observations data simulated by Pooley can be downloaded  here  and saved, e.g. to  path/to/data/ . Next, load the observations data using:  y = get_observations_from_file( path/to/data/pooley.csv )  Now we can run an MCMC analysis based on the simulated datset:  julia  rs = run_met_hastings_mcmc(model, y, [0.0025, 0.12]);\nrunning MCMC...\n finished (sample \u03bc = [0.00342388, 0.11487])  Visual inspection of the Markov chain using the traceplot is one way of assessing the convergence of the algorithm:  plot_parameter_trace(rs, 1);   The marginal distribution of parameters can be plotted by calling:  julia  plot_parameter_marginal(rs, 1)\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      (0.001,0.0015] \u2502\u2587 295                                   \u2502\n      (0.0015,0.002] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 3378                    \u2502\n      (0.002,0.0025] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 6960    \u2502\n      (0.0025,0.003] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 7700 \u2502\n      (0.003,0.0035] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 7265   \u2502\n      (0.0035,0.004] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 5425           \u2502\n      (0.004,0.0045] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 3148                     \u2502\n      (0.0045,0.005] \u2502\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587 2092                          \u2502\n      (0.005,0.0055] \u2502\u2587\u2587\u2587\u2587\u2587 1023                              \u2502\n      (0.0055,0.006] \u2502\u2587\u2587\u2587 675                                 \u2502\n      (0.006,0.0065] \u2502\u2587\u2587 494                                  \u2502\n   \u03b8\u2081 (0.0065,0.007] \u2502\u2587 271                                   \u2502\n      (0.007,0.0075] \u2502 68                                     \u2502\n      (0.0075,0.008] \u2502\u2587 138                                   \u2502\n      (0.008,0.0085] \u2502 76                                     \u2502\n      (0.0085,0.009] \u2502 80                                     \u2502\n      (0.009,0.0095] \u2502 111                                    \u2502\n       (0.0095,0.01] \u2502\u2587 273                                   \u2502\n       (0.01,0.0105] \u2502\u2587 195                                   \u2502\n      (0.0105,0.011] \u2502\u2587 133                                   \u2502\n      (0.011,0.0115] \u2502 67                                     \u2502\n      (0.0115,0.012] \u2502 77                                     \u2502\n      (0.012,0.0125] \u2502 57                                     \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      samples  Plotting the data with third party packages such as PyPlot is simple:  using PyPlot\nx = mcmc.samples[mcmc.adapt_period:size(mcmc.samples, 1), parameter]\nplt[:hist](x, 30)\n\nylabel( density )   A pairwise representation can be produced by calling  plot_parameter_heatmap  (see below for an example).", 
            "title": "MCMC"
        }, 
        {
            "location": "/examples/#autocorrelation", 
            "text": "Autocorrelation can be used to help determine how well the algorithm mixed by using  compute_autocorrelation . The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:   \nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}   for any given lag  l . The modified formula for multiple chains is given by:   \nR_{b,l} = \\frac{\\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]}{\\sigma^2_b}    \n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]   julia  ac = compute_autocorrelation(rs);\nmu = [0.00342388, 0.11487]\n\njulia  plot_autocorrelation(ac)\n                   \u03b8 autocorrelation\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     1 \u2502\u28a7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2808\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2818\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2819\u2877\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2818\u288e\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2811\u28cd\u28a6\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2833\u28dd\u2826\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n   R   \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u282e\u28d7\u28e4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281b\u2897\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u2897\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u28e7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u283b\u2866\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u2897\u2866\u28c4\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n       \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2819\u281b\u2833\u2836\u28a6\u28e4\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n     0 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281b\u28b7\u28e6\u28c0\u28c0\u28c0\u28c0\u28c0\u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       0                                     2000\n                          lag  Note that the latter formulation (for multiple chains) is likely to give a more accurate indication of algorithm performance. The code is virtually identical. Just replace  rs  with the results of a call to  run_gelman_diagnostic .", 
            "title": "Autocorrelation"
        }, 
        {
            "location": "/examples/#convergence-diagnostics", 
            "text": "The goal of an MCMC analysis is to construct a Markov chain that has the target distribution as its equilibrium distribution, i.e. it has converged. However assessing whether this is the case can be challenging since we do not know the target distribution. Visual inspection of the Markov chain may not be sufficient to diagnose convergence, particularly where the target distribution has local optima. Automated convergence diagnostics are therefore integrated closely with the MCMC functionality in Discuit; the Geweke test for single chains and the Gelman-Rubin for multiple chains. Just like autocorrelation, the latter, provided that the chains have been initialised with over dispersed parameters (with respect to the target distribution), provides a more reliable indication of algorithm performance (in this case, convergence).", 
            "title": "Convergence diagnostics"
        }, 
        {
            "location": "/examples/#geweke-test-of-stationarity", 
            "text": "The Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain (see Geweke, 1992; Cowles, 1996). It is given by:   \nz = \\frac{\\bar{\\theta}_{i, \\alpha} - \\bar{\\theta}_{i, \\beta}}{\\sqrt{Var(\\theta_{i, \\alpha})+Var(\\theta_{i, \\beta})})}   Geweke statistics are computed automatically for analyses run in Discuit and can be accessed directly (i.e.  rs.geweke ) or else inspected using one of the built in tools, e.g:  julia  plot_geweke_series(rs)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      2 \u2502\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2806\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n   z    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2809\u2809\u2809\u2809\u2849\u2809\u2809\u2809\u284d\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u280b\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u284d\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2801\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2801\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n     -1 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        0                                    20000  Note that the results of MCMC analyses, including Geweke statistics, can be saved to file for analysis in the companion  R package . In Julia, run:  print_mcmc_results(rs,  path/to/mcmc/data/ )  Now, in R, run:  library(Discuit)\nlibrary(gridExtra)\nrs = LoadMcmcResults( path/to/mcmc/data/ )\ntgt = c(0.003, 0.1)\ngrid.arrange(PlotGewekeSeries(rs), PlotParameterHeatmap(rs, 1, 2, tgt), nrow = 1)", 
            "title": "Geweke test of stationarity"
        }, 
        {
            "location": "/examples/#gelman-rubin-convergence-diagnostic", 
            "text": "The Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance (Gelman et al, 1992, 2014). The  estimated scale reduction  statistic (sometimes referred to as  potential scale reduction factor ) is calculated for each parameter in the model.  Let $\\bar{\\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\\theta$, within chain variance between chain variance respectively for $M$ Markov chains:   \nW = \\frac{1}{M} \\sum_{i = 1}^M \\sigma^2_i    \nB = \\frac{N}{M - 1} \\sum_{i = 1}^M (\\hat{\\theta}_i - \\hat{\\theta})^2   The estimated scale reduction statistic is given by:   \nR = \\sqrt{\\frac{d + 3}{d + 1} \\frac{N-1}{N} + (\\frac{M+1}{MN} \\frac{B}{W})}   where the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.  julia  rs = run_gelman_diagnostic(model, y, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);\nrunning gelman diagnostic... (3 chains)\n chain 1 complete.\n chain 2 complete.\n chain 3 complete.\n vv w: [2.14888e-13, 4.18479e-7]\n vv b: [1.96555e-5, 30.3574]\n var.V: [4.94066e-324, NaN]\n finished (sample \u03bc = [0.00330828, 0.109512]).", 
            "title": "Gelman-Rubin convergence diagnostic"
        }, 
        {
            "location": "/examples/#simulation", 
            "text": "The main purpose of the simulation functionality included in Discuit is to provide a source of simulated observations data for evaluation and validation of the MCMC functionality. However simulation can also be an interesting way to explore and better understand the dynamics of the model.  To produce the Lotka-Volterra example given in the paper use:  julia  model = generate_model( LOTKA , [79, 71]);\n\njulia  xi = gillespie_sim(model, [0.5, 0.0025, 0.3]);\nrunning simulation...\n finished (17520 events).\n\njulia  plot_trajectory(xi)\n                                PN simulation\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              500 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 P\n                  \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 N\n                  \u2502\u2800\u2800\u2800\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2800\u28b8\u28a7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2800\u28b8\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u2880\u28b8\u28b8\u2840\u2800\u2800\u2800\u2800\u2800\u28b0\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u2807\u2847\u2800\u2800\u2800\u2800\u28f7\u2800\u2800\u2800\u2502\n                  \u2502\u2800\u28b8\u284f\u2800\u2847\u2800\u2800\u2800\u2800\u2800\u285f\u28b9\u2840\u2800\u2800\u2800\u2800\u2800\u28f6\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u28c7\u2800\u2800\u2800\u28b0\u283f\u2844\u2800\u2800\u2502\n   population     \u2502\u2800\u285e\u28e7\u2800\u28c7\u2800\u2800\u2800\u2800\u28a0\u2807\u2800\u2847\u2800\u2800\u2800\u2800\u28b8\u2819\u2847\u2800\u2800\u28b8\u28b6\u28f4\u2844\u2800\u2800\u28a0\u28fe\u2800\u28b8\u2800\u2800\u2800\u28f8\u2800\u2847\u2800\u2800\u2502\n                  \u2502\u2800\u2847\u28ff\u2800\u28b8\u2800\u2800\u2800\u2800\u28ff\u2840\u2800\u28b3\u2800\u2800\u2800\u2880\u287c\u2800\u28b3\u2800\u2800\u284f\u2808\u2801\u28b3\u2800\u2800\u28b8\u28ff\u2844\u2838\u2844\u2800\u28f0\u28fb\u2800\u28b9\u2800\u2800\u2502\n                  \u2502\u2800\u28c7\u28ff\u2800\u2808\u28e7\u2800\u2800\u28f8\u28fb\u28e7\u2800\u28b8\u2844\u2800\u2800\u28f8\u28a7\u2800\u28b8\u2844\u28a0\u2847\u2800\u2800\u2818\u2847\u2800\u285e\u2847\u2847\u2800\u28c7\u2800\u284f\u284f\u2847\u2808\u2847\u2800\u2502\n                  \u2502\u28b8\u28b9\u28b8\u2800\u2800\u2818\u28c7\u2880\u28ef\u2847\u28b8\u2840\u2800\u28b3\u28e0\u28b6\u281f\u2838\u2844\u2800\u28bf\u28fe\u28b7\u2880\u2800\u2800\u28a7\u2800\u28f7\u2803\u2847\u2800\u28b8\u2880\u28f7\u2803\u2847\u2800\u28b9\u2840\u2502\n                  \u2502\u28b8\u28b8\u2808\u2847\u2800\u2800\u2838\u28fe\u281f\u2801\u2808\u28c7\u2800\u2800\u28bb\u285f\u2800\u2800\u28a7\u2800\u2880\u2847\u2818\u283b\u28e6\u2800\u2818\u28be\u287f\u2800\u28a7\u2800\u2818\u28fe\u287e\u2800\u28a7\u2800\u2800\u28b3\u2502\n                  \u2502\u28cf\u285e\u2800\u28c7\u2800\u2800\u2880\u285f\u2800\u2800\u2800\u28b9\u2840\u28b0\u280b\u2800\u2800\u2800\u2818\u2846\u287e\u2800\u2800\u2800\u2838\u28c6\u28f4\u280f\u2800\u2800\u28b8\u2800\u2880\u287f\u2803\u2800\u2838\u2844\u2880\u28f0\u2502\n                  \u2502\u2808\u2800\u2800\u2839\u2874\u281f\u281e\u2800\u2800\u2800\u2800\u2800\u2833\u280f\u2800\u2800\u2800\u2800\u2800\u281b\u2803\u2800\u2800\u2800\u2800\u2808\u2801\u2800\u2800\u2800\u2808\u28a7\u285f\u2800\u2800\u2800\u2800\u2833\u281e\u2801\u2502\n                0 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  0                                      100\n                                    time  The maximum time of the simulation and number of observations to draw can also be specified, e.g.  generate_model(\"LOTKA\", [79, 71], 100.0, 10) .", 
            "title": "Simulation"
        }, 
        {
            "location": "/examples/#custom-mcmc", 
            "text": "In addition to the two proposal algorithms included with the packages by default, Discuit allows for users to develop their own algorithms for data augmented MCMC via the alternative custom MCMC framework, while still taking advantage of features including automated, finite adaptive multivariate \u03b8 proposals.  In some cases may wish to simply tweak the proposal algorithms included in the source code repositories for minor performance gains in certain models, but the custom MCMC framework can also be useful in cases where the augmented data aspects of the model have specific or complex constraints, such as the next example which is based on an analysis of a smallpox outbreak within a closed community in Abakaliki, Nigeria by O'Neill and Roberts (ADD CITATION). First we generate a standard  SIR  model and set the  t0_index = 3 :  julia  model = generate_model( SIR , [119, 1, 0]);\n\njulia  model.t0_index = 3;  Next we define the \"medium\" prior used by O'Neill and Roberts, with some help from the  Distributions.jl  package:    Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n\u001b[?25l\u001b[2K\u001b[?25h Resolving package versions...\n  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`\n  [31c24e10] + Distributions v0.16.4\n  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`\n [no changes]\n\njulia  using Distributions;\n\njulia  p1 = Gamma(10, 0.0001);\n\njulia  p2 = Gamma(10, 0.01);\n\njulia  function prior_density(parameters::Array{Float64, 1})\n           return parameters[3]   0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0\n       end\nprior_density (generic function with 1 method)\n\njulia  model.prior_density = prior_density;  The observation model is replaced with one that returns  log(1)  since we will only propose sequences consitent with the observed recoveries and $\\pi(\\xi | \\theta)$ is evaluated automatically by Discuit):  julia  observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0\nobservation_model (generic function with 1 method)\n\njulia  model.observation_model = observation_model;  Next we define an array  t  to contain the recovery times reported by O'Neill and Roberts and a simple  Observations  variable which consists of the maximum event time and an empty two dimensional array:  julia  t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];\n\njulia  y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))\nObservations([67.0], [140682978773872])  We also need to define an initial state using the  generate_custom_x0  function using some parameter values and a vector of event times and corresponding event types, consistent with  t :  julia  evt_tm = Float64[];\n\njulia  evt_tp = Int64[];\n\njulia  for i in 1:(length(t) - 1)# infections at arbitrary t   t0\n           push!(evt_tm, -4.0)\n           push!(evt_tp, 1)\n       end\n\njulia  for i in eachindex(t)     # recoveries\n           push!(evt_tm, t[i])\n           push!(evt_tp, 2)\n       end\n\njulia  x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);  The final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit). Since it is assumed that the total number of events is known we can construct an algorithm that simply changes the time of an event in the trajectory. Events are chosen and new times drawn from uniform distributions ensuring that:   \ng(X_{f \\rightarrow i}) = g(X_{i \\rightarrow f})   such that the terms cancel in the Metropolis-Hastings acceptance equation. Some additional information is available regarding the times of recoveries; they are known to within a day. We therefore propose new recovery event times such that they remain within the time frame of a single time unit, which correspond to days in this model:  julia  function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)\n           t0 = xf_parameters.value[model.t0_index]\n           ## move\n           seq_f = deepcopy(xi.trajectory)\n           # choose event and define new one\n           evt_i = rand(1:length(xi.trajectory.time))\n           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()\n           evt_tp = xi.trajectory.event_type[evt_i]\n           # remove old one\n           splice!(seq_f.time, evt_i)\n           splice!(seq_f.event_type, evt_i)\n           # add new one\n           if evt_tm   seq_f.time[end]\n               push!(seq_f.time, evt_tm)\n               push!(seq_f.event_type, evt_tp)\n           else\n               for i in eachindex(seq_f.time)\n                   if seq_f.time[i]   evt_tm\n                       insert!(seq_f.time, i, evt_tm)\n                       insert!(seq_f.event_type, i, evt_tp)\n                       break\n                   end\n               end\n           end\n           # compute ln g(x)\n           prop_lk = 1.0\n           ## evaluate full likelihood for trajectory proposal and return\n           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)\n       end # end of std proposal function\ncustom_proposal (generic function with 1 method)  We can now run the MCMC analysis:  julia  rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);\nrunning custom MCMC...\n finished (sample \u03bc = [0.000993775, 0.104761, -3.18788]).  The output from the custom MCMC functionality is in the same format as the those produced using the core functions and thus be analysed in the same way. In this case the results were saved to file and analysed in R, in the manner described above:   The traceplots indicate good mixing and the results are fairly similar to that obtained by O'Neill and Roberts given the differences in the models used.", 
            "title": "Custom MCMC"
        }, 
        {
            "location": "/examples/#references", 
            "text": "@article{gillespie_exact_1977,\n    title = {Exact stochastic simulation of coupled chemical reactions},\n    volume = {81},\n    issn = {0022-3654, 1541-5740},\n    url = {http://pubs.acs.org/doi/abs/10.1021/j100540a008},\n    doi = {10.1021/j100540a008},\n    language = {en},\n    number = {25},\n    urldate = {2017-02-18},\n    journal = {The Journal of Physical Chemistry},\n    author = {Gillespie, Daniel T.},\n    month = dec,\n    year = {1977},\n    pages = {2340--2361}\n}  @incollection{geweke_evaluating_1992,\n    title = {Evaluating the {Accuracy} of {Sampling}-{Based} {Approaches} to the {Calculation} of {Posterior} {Moments}},\n    abstract = {Data augmentation and Gibbs sampling are two closely related, sampling-based approaches to the calculation of posterior moments. The fact that each produces a sample whose constituents are neither independent nor identically distributed complicates the assessment of convergence and numerical accuracy of the approximations to the expected value of functions of interest under the posterior. In this paper methods from spectral analysis are used to evaluate numerical accuracy formally and construct diagnostics for convergence. These methods are illustrated in the normal linear model with informative priors, and in the Tobit-censored regression model.},\n    booktitle = {{IN} {BAYESIAN} {STATISTICS}},\n    publisher = {University Press},\n    author = {Geweke, John},\n    year = {1992},\n    pages = {169--193}\n}  @article{cowles_markov_1996,\n    title = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}: {A} {Comparative} {Review}},\n    volume = {91},\n    issn = {01621459},\n    shorttitle = {Markov {Chain} {Monte} {Carlo} {Convergence} {Diagnostics}},\n    url = {http://www.jstor.org/stable/2291683},\n    doi = {10.2307/2291683},\n    number = {434},\n    urldate = {2018-03-20},\n    journal = {Journal of the American Statistical Association},\n    author = {Cowles, Mary Kathryn and Carlin, Bradley P.},\n    month = jun,\n    year = {1996},\n    pages = {883}\n}  @article{gelman_inference_1992,\n    title = {Inference from iterative simulation using multiple sequences},\n    journal = {Statistical science},\n    author = {Gelman, Andrew and Rubin, Donald B.},\n    year = {1992},\n    pages = {457--472}\n}\n@book{gelman_bayesian_2014,\n    title = {Bayesian data analysis},\n    isbn = {978-1-4398-9820-8 978-1-4398-4096-2},\n    language = {English},\n    urldate = {2018-03-18},\n    author = {Gelman, Andrew and Carlin, John B and Stern, Hal Steven and Dunson, David B and Vehtari, Aki and Rubin, Donald B},\n    year = {2014},\n    note = {OCLC: 909477393}\n}", 
            "title": "References"
        }, 
        {
            "location": "/models/", 
            "text": "Discuit.jl models\n\n\nThis section describes the library of predefined models in Discuit. Models can also be user defined, or generated and modified according to need. The models included are mostly epidemiological (see \nMiscellaneous\n for other types of model). The next section described the model generating function and an overview of default model components.\n\n\n\n\nGenerating models\n\n\nPre defined models can be invoked by calling:\n\n\ngenerate_model(model_name, initial_condition, \u03c3 = 2.0)\n\n\n\n\n Examples \n\n\nmodel = generate_model(\nSIS\n, [100, 1]]);\nmodel = generate_model(\nSEIR\n, [100, 0, 1, 0]], 1.0)\n\n\n\n\n\n\nDefaults\n\n\nDiscuit.jl models\n are \nmutable struct\ns so it is convenient to generate pre defined with default values for most things and allow the user to overwrite as required. Only the 'model*name' and \ninitial*condition\nare required to call\ngenerate_model\n. The following gives an overview of important defaults that the user should note before proceeding with their analysis.\n\n\n\n\nObservation function\n\n\nThe default \nmodel.obs_function\n returns a vector representing the state of the system at obsertion time $t_y$, i.e.:\n\n\nobs_fn(population::Array{Int64, 1}) = population\n\n\n\n\n\n\nObservation likelihood model\n\n\nThe default \nmodel.observation_model\n is Gaussian with observation error \n\u03c3 = 2.0\n by default, which can be changed by providing an optional third parameter to \ngenerate_model\n per the example above,\n\n\nADD latex.\n\n\n\n\nPrior density function\n\n\nThe default \nmodel.prior\n density function is weak, e.g. in a simple two parameter model it is equivalent to:\n\n\nfunction weak_prior(parameters::Array{Float64, 1})\n    parameters[1] \n 0.0 || return 0.0\n    parameters[2] \n 0.0 || return 0.0\n    return 1.0\nend\n\n\n\n\nNote that all models generated by the ADD XREF have \nt0_index = 0\n by default and that changing this parameter will likely require replacing the the density with something like:\n\n\nfunction weak_prior(parameters::Array{Float64, 1})\n    parameters[1] \n 0.0 || return 0.0\n    parameters[2] \n 0.0 || return 0.0\n    parameters[3] \n 0.0 || return 0.0\n    return 1.0\nend\n\n\n\n\nwhere \nparameters[3]\n is designated as the, e.g. initial infection, which is assumed to have taken place prior to e.g. the initial observation at t = 0.0.\n\n\n\n\nStandard Kermack-McKendrick models\n\n\nThe standard Kermack-McKendrick SIR model can be used to model diseases which confer lasting immunity or situations where infected individuals have been detected and quarantined for treatment (Kermack and McKendrick, 1991). ADD REF: kermack\ncontributions\n1991\n\n\nDiscuit.generate_model(\nSI\n, [100, 1])\n\n\n\n\nThe susceptible-infectious (\n\"SI\"\n) is a very basic model with only one type of event. Individuals who become infected remain infected for the duration of trajectory.\n\n\n\n\nDiscuit.generate_model(\nSIR\n, [100, 1, 0])\n\n\n\n\nThe classic Kermack-McKendrick susceptible-infectious-recovered (\n\"SIR\"\n) model.\n\n\n\n\nDiscuit.generate_model(\nSIS\n, [100, 1])\n\n\n\n\n\n\nThe susceptible-infectious-susceptible (\n\"SIS\"\n) model is an extension of the classic Kermack-McKendrick \nSIR\n model for diseases which do not confer lasting immunity.\n\n\n\n\nDiscuit.generate_model(\nSIRS\n, [100, 1, 0])\n\n\n\n\nThe susceptible-infectious-recovered-susceptible (\n\"SIRS\"\n) model incorporates all of the above, i.e. it is for diseases which do not confer long lasting immunity.\n\n\n\n\n\n\nLatent Kermack-McKendrick models\n\n\nThe next class of models extend the classic Kermack-McKendrick by accounting for an exposed state \nE\n between infection and the onset of infectiousness. For example, the susceptible-exposed-infectious \nSEI\n model;\n\n\nDiscuit.generate_model(\nSEI\n, [100, 1, 0])\n\n\n\n\n\n\nA notable extension of the \nSEI\n model is the \nSEIR\n:\n\n\nDiscuit.generate_model(\nSEIR\n, [100, 1, 0, 0])\n\n\n\n\n\n\nDiscuit.generate_model(\nSEIS\n, [100, 1, 0])\n\n\n\n\n\n\nDiscuit.generate_model(\nSEIRS\n, [100, 1, 0, 0])\n\n\n\n\n\n\n\n\nMiscellaneous\n\n\n\n\nLotka-Volterra predator-prey model\n\n\n\n\nThe Lotka-Volterra model is well known for its application to predator-prey interactions but can also be used to model chemical, bio molecular and other auto regulating biological systems. Compartments are labelled Predator, pRey. The \nmodel.rate_function\n for prey reproduction, predator reproduction and predator death is defined as:\n\n\nfunction lotka_rf(output, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n  # prey; predator reproduction; predator death\n  output[1] = parameters[1] * population[2]\n  output[2] = parameters[2] * population[1] * population[2]\n  output[3] = parameters[3] * population[1]\nend\n\n\n\n\nwith the transition matrix given as:\n\n\nm_transition = [ 0 1; 1 -1; -1  0 ]\n\n\n\n\n\n\nRoss-MacDonald malaria model\n\n\nThe Ross-MacDonald malaria model is an extension of the Kermack-McKendrick SIS model which accounts for two species, human and mosquito. ADD CITATION. This example is simplified in two ways...\n\n\n\n\n\n\nSETIR model for bTB\n\n\n\n\n\n\nMore information\n\n\nADD list...\n\n\n[Compartmental models in epidemiology](https://en.wikipedia.org/wiki/Compartmental\nmodels\nin_epidemiology] (Wiki).\n\n\n\n\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n@article{kermack_contributions_1991,\n    title = {Contributions to the mathematical theory of epidemics\u2014{I}},\n    volume = {53},\n    number = {1-2},\n    journal = {Bulletin of mathematical biology},\n    author = {Kermack, William O. and McKendrick, Anderson G.},\n    year = {1991},\n    pages = {33--55}\n}\n@article{pooley_using_2015,\n    title = {Using model-based proposals for fast parameter inference on discrete state space, continuous-time {Markov} processes},\n    volume = {12},\n    issn = {1742-5689, 1742-5662},\n    url = {http://rsif.royalsocietypublishing.org/cgi/doi/10.1098/rsif.2015.0225},\n    doi = {10.1098/rsif.2015.0225},\n    language = {en},\n    number = {107},\n    urldate = {2017-02-20},\n    journal = {Journal of The Royal Society Interface},\n    author = {Pooley, C. M. and Bishop, S. C. and Marion, G.},\n    month = may,\n    year = {2015},\n    pages = {20150225--20150225}\n}\n@article{berryman_orgins_1992,\n    title = {The {Orgins} and {Evolution} of {Predator}-{Prey} {Theory}},\n    volume = {73},\n    issn = {00129658},\n    url = {http://doi.wiley.com/10.2307/1940005},\n    doi = {10.2307/1940005},\n    language = {en},\n    number = {5},\n    urldate = {2018-03-12},\n    journal = {Ecology},\n    author = {Berryman, Alan A.},\n    month = oct,\n    year = {1992},\n    pages = {1530--1535}\n}\n@article{macdonald_analysis_1952,\n    title = {The analysis of equilibrium in malaria},\n    volume = {49},\n    issn = {0041-3240},\n    language = {eng},\n    number = {9},\n    journal = {Tropical Diseases Bulletin},\n    author = {Macdonald, G.},\n    month = sep,\n    year = {1952},\n    pmid = {12995455},\n    keywords = {Humans, Malaria, MALARIA},\n    pages = {813--829}\n}", 
            "title": "Models"
        }, 
        {
            "location": "/models/#discuitjl-models", 
            "text": "This section describes the library of predefined models in Discuit. Models can also be user defined, or generated and modified according to need. The models included are mostly epidemiological (see  Miscellaneous  for other types of model). The next section described the model generating function and an overview of default model components.", 
            "title": "Discuit.jl models"
        }, 
        {
            "location": "/models/#generating-models", 
            "text": "Pre defined models can be invoked by calling:  generate_model(model_name, initial_condition, \u03c3 = 2.0)   Examples   model = generate_model( SIS , [100, 1]]);\nmodel = generate_model( SEIR , [100, 0, 1, 0]], 1.0)", 
            "title": "Generating models"
        }, 
        {
            "location": "/models/#defaults", 
            "text": "Discuit.jl models  are  mutable struct s so it is convenient to generate pre defined with default values for most things and allow the user to overwrite as required. Only the 'model*name' and  initial*condition are required to call generate_model . The following gives an overview of important defaults that the user should note before proceeding with their analysis.", 
            "title": "Defaults"
        }, 
        {
            "location": "/models/#observation-function", 
            "text": "The default  model.obs_function  returns a vector representing the state of the system at obsertion time $t_y$, i.e.:  obs_fn(population::Array{Int64, 1}) = population", 
            "title": "Observation function"
        }, 
        {
            "location": "/models/#observation-likelihood-model", 
            "text": "The default  model.observation_model  is Gaussian with observation error  \u03c3 = 2.0  by default, which can be changed by providing an optional third parameter to  generate_model  per the example above,  ADD latex.", 
            "title": "Observation likelihood model"
        }, 
        {
            "location": "/models/#prior-density-function", 
            "text": "The default  model.prior  density function is weak, e.g. in a simple two parameter model it is equivalent to:  function weak_prior(parameters::Array{Float64, 1})\n    parameters[1]   0.0 || return 0.0\n    parameters[2]   0.0 || return 0.0\n    return 1.0\nend  Note that all models generated by the ADD XREF have  t0_index = 0  by default and that changing this parameter will likely require replacing the the density with something like:  function weak_prior(parameters::Array{Float64, 1})\n    parameters[1]   0.0 || return 0.0\n    parameters[2]   0.0 || return 0.0\n    parameters[3]   0.0 || return 0.0\n    return 1.0\nend  where  parameters[3]  is designated as the, e.g. initial infection, which is assumed to have taken place prior to e.g. the initial observation at t = 0.0.", 
            "title": "Prior density function"
        }, 
        {
            "location": "/models/#standard-kermack-mckendrick-models", 
            "text": "The standard Kermack-McKendrick SIR model can be used to model diseases which confer lasting immunity or situations where infected individuals have been detected and quarantined for treatment (Kermack and McKendrick, 1991). ADD REF: kermack contributions 1991  Discuit.generate_model( SI , [100, 1])  The susceptible-infectious ( \"SI\" ) is a very basic model with only one type of event. Individuals who become infected remain infected for the duration of trajectory.   Discuit.generate_model( SIR , [100, 1, 0])  The classic Kermack-McKendrick susceptible-infectious-recovered ( \"SIR\" ) model.   Discuit.generate_model( SIS , [100, 1])   The susceptible-infectious-susceptible ( \"SIS\" ) model is an extension of the classic Kermack-McKendrick  SIR  model for diseases which do not confer lasting immunity.   Discuit.generate_model( SIRS , [100, 1, 0])  The susceptible-infectious-recovered-susceptible ( \"SIRS\" ) model incorporates all of the above, i.e. it is for diseases which do not confer long lasting immunity.", 
            "title": "Standard Kermack-McKendrick models"
        }, 
        {
            "location": "/models/#latent-kermack-mckendrick-models", 
            "text": "The next class of models extend the classic Kermack-McKendrick by accounting for an exposed state  E  between infection and the onset of infectiousness. For example, the susceptible-exposed-infectious  SEI  model;  Discuit.generate_model( SEI , [100, 1, 0])   A notable extension of the  SEI  model is the  SEIR :  Discuit.generate_model( SEIR , [100, 1, 0, 0])   Discuit.generate_model( SEIS , [100, 1, 0])   Discuit.generate_model( SEIRS , [100, 1, 0, 0])", 
            "title": "Latent Kermack-McKendrick models"
        }, 
        {
            "location": "/models/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/models/#lotka-volterra-predator-prey-model", 
            "text": "The Lotka-Volterra model is well known for its application to predator-prey interactions but can also be used to model chemical, bio molecular and other auto regulating biological systems. Compartments are labelled Predator, pRey. The  model.rate_function  for prey reproduction, predator reproduction and predator death is defined as:  function lotka_rf(output, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n  # prey; predator reproduction; predator death\n  output[1] = parameters[1] * population[2]\n  output[2] = parameters[2] * population[1] * population[2]\n  output[3] = parameters[3] * population[1]\nend  with the transition matrix given as:  m_transition = [ 0 1; 1 -1; -1  0 ]", 
            "title": "Lotka-Volterra predator-prey model"
        }, 
        {
            "location": "/models/#ross-macdonald-malaria-model", 
            "text": "The Ross-MacDonald malaria model is an extension of the Kermack-McKendrick SIS model which accounts for two species, human and mosquito. ADD CITATION. This example is simplified in two ways...", 
            "title": "Ross-MacDonald malaria model"
        }, 
        {
            "location": "/models/#setir-model-for-btb", 
            "text": "", 
            "title": "SETIR model for bTB"
        }, 
        {
            "location": "/models/#more-information", 
            "text": "ADD list...  [Compartmental models in epidemiology](https://en.wikipedia.org/wiki/Compartmental models in_epidemiology] (Wiki).", 
            "title": "More information"
        }, 
        {
            "location": "/models/#references", 
            "text": "@article{kermack_contributions_1991,\n    title = {Contributions to the mathematical theory of epidemics\u2014{I}},\n    volume = {53},\n    number = {1-2},\n    journal = {Bulletin of mathematical biology},\n    author = {Kermack, William O. and McKendrick, Anderson G.},\n    year = {1991},\n    pages = {33--55}\n}\n@article{pooley_using_2015,\n    title = {Using model-based proposals for fast parameter inference on discrete state space, continuous-time {Markov} processes},\n    volume = {12},\n    issn = {1742-5689, 1742-5662},\n    url = {http://rsif.royalsocietypublishing.org/cgi/doi/10.1098/rsif.2015.0225},\n    doi = {10.1098/rsif.2015.0225},\n    language = {en},\n    number = {107},\n    urldate = {2017-02-20},\n    journal = {Journal of The Royal Society Interface},\n    author = {Pooley, C. M. and Bishop, S. C. and Marion, G.},\n    month = may,\n    year = {2015},\n    pages = {20150225--20150225}\n}\n@article{berryman_orgins_1992,\n    title = {The {Orgins} and {Evolution} of {Predator}-{Prey} {Theory}},\n    volume = {73},\n    issn = {00129658},\n    url = {http://doi.wiley.com/10.2307/1940005},\n    doi = {10.2307/1940005},\n    language = {en},\n    number = {5},\n    urldate = {2018-03-12},\n    journal = {Ecology},\n    author = {Berryman, Alan A.},\n    month = oct,\n    year = {1992},\n    pages = {1530--1535}\n}\n@article{macdonald_analysis_1952,\n    title = {The analysis of equilibrium in malaria},\n    volume = {49},\n    issn = {0041-3240},\n    language = {eng},\n    number = {9},\n    journal = {Tropical Diseases Bulletin},\n    author = {Macdonald, G.},\n    month = sep,\n    year = {1952},\n    pmid = {12995455},\n    keywords = {Humans, Malaria, MALARIA},\n    pages = {813--829}\n}", 
            "title": "References"
        }, 
        {
            "location": "/manual/", 
            "text": "Discuit.jl manual\n\n\nSee \nDiscuit.jl examples\n for a brief introduction to the package's core functionality.\n\n\n\n\nDiscuit.jl manual\n\n\nTypes\n\n\nFunctions\n\n\ncore functionality\n\n\nmodel helpers\n\n\nutilities\n\n\nvisualisation\n\n\ncustom MCMC\n\n\n\n\n\n\nIndex\n\n\nReferences\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nDiscuit.DiscuitModel\n \n \nType\n.\n\n\nDiscuitModel\n\n\n\n\nFields\n\n\n\n\nmodel_name\n          \u2013 string, e,g, \n\"SIR\"\n.\n\n\ninitial_condition\n   \u2013 initial condition\n\n\nrate_function\n       \u2013 event rate function.\n\n\nm_transition\n        \u2013 transition matrix.\n\n\n`observation_function \u2013 observation function, use this to add 'noise' to simulated observations.\n\n\nprior_density\n       \u2013 prior density function.\n\n\nobservation_model\n   \u2013 observation model likelihood function.\n\n\nt0_index\n            \u2013 index of the parameter that represents the initial time. \n0\n if fixed at \n0.0\n.\n\n\n\n\nA \nmutable struct\n which represents a DSSCT model (see \nDiscuit.jl models\n for further details).\n\n\nsource\n\n\n#\n\n\nDiscuit.SimResults\n \n \nType\n.\n\n\nSimResults\n\n\n\n\nFields\n\n\n\n\ntrajectory\n      \u2013 a variable of type \nTrajectory\n.\n\n\npopulation\n      \u2013 gives the state of the system after each event.\n\n\nobservations\n    \u2013 variable of type \nObservations\n.\n\n\n\n\nThe results of a simulation.\n\n\nsource\n\n\n#\n\n\nDiscuit.Trajectory\n \n \nType\n.\n\n\nTrajectory\n\n\n\n\nFields\n\n\n\n\ntime\n        \u2013 event times.\n\n\nevent_type\n  \u2013 event type, index of \nmodel.rate_function\n.\n\n\n\n\nA single realisation of the model.\n\n\nsource\n\n\n#\n\n\nDiscuit.Observations\n \n \nType\n.\n\n\nObservations\n\n\n\n\nFields\n\n\n\n\ntime\n    \u2013 observation times.\n\n\nval\n     \u2013 observation values.\n\n\n\n\nExamples\n\n\n# pooley dataset\npooley = Observations([20, 40, 60, 80, 100], [0 18; 0 65; 0 70; 0 66; 0 67])\n\n\n\n\nStores one column vector of observation times and one or more column vectors of observation integer values.\n\n\nsource\n\n\n#\n\n\nDiscuit.MCMCResults\n \n \nType\n.\n\n\nMCMCResults\n\n\n\n\nFields\n\n\n\n\nsamples\n     \u2013 two dimensional array of samples.\n\n\nmc_accepted\n \u2013 proposal accepted\n\n\nmean\n        \u2013 sample mean.\n\n\ncovar\n       \u2013 parameter covariance matrix.\n\n\n\n\nThe results of an MCMC analysis including samples; mean; covariance matrix; adaptation period; and results of the Geweke test of stationarity.\n\n\nsource\n\n\n#\n\n\nDiscuit.GelmanResults\n \n \nType\n.\n\n\nGelmanResults\n\n\n\n\nFields\n\n\n\n\nmu\n      \u2013 between chain sample mean.\n\n\nsre\n     \u2013 scale reduction factor estimate.\n\n\nsre_ll\n  \u2013 scale reduction factor lower confidence interval.\n\n\nsre_ul\n  \u2013 scale reduction factor upper confidence interval.\n\n\nmcmc\n    \u2013 array of \nMCMCResults\n\n\n\n\nResults of a Gelman Rubin convergence diagnostic including n \nMCMCResults\n variables; \nmu\n; and the scale reduction factor estimates (\nsre\n).\n\n\nsource\n\n\n\n\nFunctions\n\n\nThis section is organised in three parts:\n\n\n\n\nthe main package \ncore functionality\n for working with standard Discuit models\n\n\nutilities\n, for loading to and from file\n\n\ncustom MCMC\n, for running custom algorithms\n\n\n\n\n\n\ncore functionality\n\n\n#\n\n\nDiscuit.set_random_seed\n \n \nFunction\n.\n\n\nset_random_seed(seed)\n\n\n\n\nExamples\n\n\nset_random_seed(1234)\n\n\n\n\nDoes what it says on the tin but only if you give it an integer.\n\n\nsource\n\n\n#\n\n\nDiscuit.gillespie_sim\n \n \nFunction\n.\n\n\ngillespie_sim(model, parameters, tmax = 100.0, num_obs = 5)\n\n\n\n\nParameters\n\n\n\n\nmodel\n       \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nparameters\n  \u2013 model parameters.\n\n\ntmax\n        \u2013 maximum time.\n\n\nnum_obs\n     \u2013 number of observations to draw,\n\n\n\n\nRun a DGA simulation on \nmodel\n. Returns a SimResults containing the trajectory and observations data.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_met_hastings_mcmc\n \n \nFunction\n.\n\n\nrun_met_hastings_mcmc(model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\ninitial_parameters\n  \u2013 initial model parameters (i.e. sample).\n\n\nsteps\n               \u2013 number of iterations.\n\n\nmbp\n                 \u2013 model based proposals (MBP). Set \nmbp = false\n for standard proposals.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.\n\n\n\n\nRun an MCMC analysis based on \nmodel\n and \nobs_data\n of type \nObservations\n. The number of samples obtained is equal to \nsteps\n - \nadapt_period\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_gelman_diagnostic\n \n \nFunction\n.\n\n\nrun_gelman_diagnostic(m_model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\ninitial_parameters\n  \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.\n\n\nsteps\n               \u2013 number of iterations.\n\n\nadapt_period\n        \u2013 number of discarded samples.\n\n\nmbp\n                 \u2013 model based proposals (MBP). Set \nmbp = false\n for standard proposals.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.\n\n\n\n\nRun n (equal to the number of rows in \ninitial_parameters\n)  MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.\n\n\nsource\n\n\n#\n\n\nDiscuit.compute_autocorrelation\n \n \nFunction\n.\n\n\ncompute_autocorrelation(mcmc, lags = 200)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n    \u2013 \nMCMCResults\n variable.\n\n\nlags\n    \u2013 the number of lags to compute. Default: 200.\n\n\n\n\nCompute autocorrelation R for a single Markov chain. Autocorrelation can be used to help determine how well the algorithm mixed by using \ncompute_autocorrelation(rs.mcmc)\n. The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:\n\n\n\n\n\nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}\n\n\n\n\n\nfor any given lag \nl\n.\n\n\nsource\n\n\ncompute_autocorrelation(mcmc, lags = 200)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n    \u2013 an array of \nMCMCResults\n variables.\n\n\nlags\n    \u2013 the number of lags to compute. Default: 200.\n\n\n\n\nCompute autocorrelation R' for a two or more Markov chains. The formula for multiple chains is given by:\n\n\n\n\n\nR^{\\prime}_l = \\frac{\\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]}{\\sigma^2_b}\n\n\n\n\n\n\n\n\n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]\n\n\n\n\n\nwhere .\n\n\nsource\n\n\n\n\nmodel helpers\n\n\nDiscuit.jl\n includes tools for generating components which can help minimise the amount of work required to generate customised \nDiscuitModel\ns, including \ngenerate_model(...)\n which is used to access a library of pre defined \nDiscuit.jl models\n.\n\n\n#\n\n\nDiscuit.generate_generic_obs_function\n \n \nFunction\n.\n\n\ngenerate_generic_obs_function()\n\n\n\n\nGenerates a simple observation function for use in a \nDiscuitModel\n. Not very realistic...\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_weak_prior\n \n \nMethod\n.\n\n\ngenerate_weak_prior(n)\n\n\n\n\nParameters\n\n\n\n\nn\n   \u2013 the number of parameters in the model.\n\n\n\n\nExamples\n\n\ngenerate_weak_prior(1)\n\n\n\n\nGenerate a \"weak\" prior density function, where \nn\n is the number of parameters in the model.\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_gaussian_obs_model\n \n \nFunction\n.\n\n\ngenerate_gaussian_obs_model(n, \u03c3 = 2.0)\n\n\n\n\nParameters\n\n\n\n\nn\n   \u2013 the number of discrete states in the model.\n\n\n\u03c3\n   \u2013 observation error.\n\n\n\n\ntest latex eqn:\n\n\n\n\n\n\frac{n!}{k!(n - k)!} = \binom{n}{k}\n\n\n\n\n\nExamples\n\n\np = generate_weak_prior(1)\n\n\n\n\nGenerate a Gaussian observation model for a model with \nn\n states. Optionally specify observation error \n\u03c3\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_model\n \n \nFunction\n.\n\n\ngenerate_model(model_name, initial_condition, \u03c3 = 2.0)\n\n\n\n\nParameters\n\n\n\n\nmodel_name\n          \u2013 the model, e.g. \"SI\"; \"SIR\"; \"SEIR\"; etc\n\n\ninitial_condition\n   \u2013 initial condition.\n\n\n\u03c3\n                   \u2013 observation error.\n\n\n\n\nmodel_name\n \noptions\n\n\n\n\n\"SI\"\n\n\n\"SIR\"\n\n\n\"SIS\"\n\n\n\"SEI\"\n\n\n\"SEIR\"\n\n\n\"SEIS\"\n\n\n\"SEIRS\"\n\n\n\"PREDPREY\"\n\n\n\"ROSSMAC\"\n\n\n\n\nExamples\n\n\ngenerate_model(\nSIS\n, [100,1])\n\n\n\n\nGenerates a \nDiscuitModel\n. Optionally specify observation error \n\u03c3\n.\n\n\nsource\n\n\n\n\nutilities\n\n\n#\n\n\nDiscuit.print_trajectory\n \n \nFunction\n.\n\n\nprint_trajectory(model, sim_results, fpath)\n\n\n\n\nParameters\n\n\n\n\nmodel\n       \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nsim_results\n \u2013 \nSimResults\n variable.\n\n\nfpath\n       \u2013 the destination file path.\n\n\n\n\nSave an augmented trajectory from a variable of type \nSimResults\n (i.e. from a call to \ngillespie_sim\n, see \nSimulation\n) to the file \nfpath\n, e.g. \"./out/sim.csv\".\n\n\nsource\n\n\n#\n\n\nDiscuit.print_observations\n \n \nFunction\n.\n\n\nprint_observations(obs_data, fpath)\n\n\n\n\nParameters\n\n\n\n\nobs_data\n    \u2013 \nObservations\n data.\n\n\nfpath\n       \u2013 the destination file path.\n\n\n\n\nSave a set of observations (e.g. from a \nSimResults\n obtained by a call to \ngillespie_sim\n to the file \nfpath\n, e.g. \"./out/obs.csv\".\n\n\nsource\n\n\n#\n\n\nDiscuit.get_observations\n \n \nFunction\n.\n\n\nget_observations(source)\n\n\n\n\nParameters\n\n\n\n\nsource\n      \u2013 \nArray\n, \nDataFrame\n or filepath (i.e. \nString\n) containing the data (with times in the first column).\n\n\n\n\nCreate and return a variable of type \nObservations\n based on a two dimensional array, \nDataFrame\n or file location.\n\n\nsource\n\n\n#\n\n\nDiscuit.print_mcmc_results\n \n \nFunction\n.\n\n\nprint_mcmc_results(mcmc, dpath)\n\n\n\n\nParameters\n\n\n\n\nresults\n \u2013 \nMCMCResults\n variable.\n\n\ndpath\n   \u2013 the path of the directory where the results will be saved.\n\n\n\n\nSave the results from a call to \nrun_met_hastings_mcmc\n or \nrun_custom_mcmc\n to the directory \ndpath\n, e.g. \"./out/mcmc/\".\n\n\nsource\n\n\n#\n\n\nDiscuit.print_gelman_results\n \n \nFunction\n.\n\n\nprint_gelman_results(results::GelmanResults, dpath::String)\n\n\n\n\nParameters\n\n\n\n\nresults\n \u2013 \nGelmanResults\n variable.\n\n\ndpath\n   \u2013 the path of the directory where the results will be saved.\n\n\n\n\nSave the results from a call to \nrun_gelman_diagnostic\n to the directory \ndpath\n, e.g. \"./out/gelman/\".\n\n\nsource\n\n\n#\n\n\nDiscuit.print_autocorrelation\n \n \nFunction\n.\n\n\nprint_autocorrelation(autocorrelation, fpath)\n\n\n\n\nParameters\n\n\n\n\nautocorrelation\n \u2013 the results of a call to \ncompute_autocorrelation\n.\n\n\nfpath\n           \u2013 the file path of the destination file.\n\n\n\n\nSave the results from a call to \ncompute_autocorrelation\n to the file \nfpath\n, e.g. \"./out/ac.csv\".\n\n\nsource\n\n\n\n\nvisualisation\n\n\n#\n\n\nDiscuit.plot_trajectory\n \n \nFunction\n.\n\n\nplot_trajectory(x)\n\n\n\n\nParameters\n\n\n\n\nx\n       \u2013 \nSimResults\n, i.e. from a call to \ngillespie_sim\n.\n\n\n\n\nPlot the trajectory of a a DGA simulation on \nmodel\n using \nUnicodePlots.jl\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.plot_parameter_trace\n \n \nFunction\n.\n\n\nplot_parameter_trace(mcmc, parameter)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n        \u2013 \nMCMCResults\n, e.g. from a call to \nrun_met_hastings_mcmc\n.\n\n\nparameter\n   \u2013 the index of the model parameter to be plotted.\n\n\n\n\nTrace plot of samples from an MCMC analysis for a given model \nparameter\n using \nUnicodePlots.jl\n.\n\n\nsource\n\n\nplot_parameter_trace(mcmc, parameter)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n        \u2013 array of \nMCMCResults\n, e.g. from a call to \nrun_gelman_diagnostic\n.\n\n\nparameter\n   \u2013 the index of the model parameter to be plotted.\n\n\n\n\nTrace plot of samples from \nn\n MCMC analyses for a given model \nparameter\n using \nUnicodePlots.jl\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.plot_parameter_marginal\n \n \nFunction\n.\n\n\nplot_parameter_marginal(mcmc, parameter)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n        \u2013 \nMCMCResults\n, e.g. from a call to \nrun_met_hastings_mcmc\n.\n\n\nparameter\n   \u2013 the index of the model parameter to be plotted.\n\n\n\n\nPlot the marginal distribution of samples from an MCMC analysis for a given model \nparameter\n using \nUnicodePlots.jl\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.plot_parameter_heatmap\n \n \nFunction\n.\n\n\nplot_parameter_heatmap(mcmc, x_parameter, y_parameter)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n        \u2013 \nMCMCResults\n, e.g. from a call to \nrun_met_hastings_mcmc\n.\n\n\nx_parameter\n   \u2013 the index of the model parameter to be plotted on the x axis.\n\n\ny_parameter\n   \u2013 the index of the model parameter to be plotted on the y axis.\n\n\n\n\nPlot the marginal distribution of samples from an MCMC analysis for two model parameters using \nUnicodePlots.jl\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.plot_geweke_series\n \n \nFunction\n.\n\n\nplot_geweke_series(mcmc)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n        \u2013 \nMCMCResults\n, e.g. from a call to \nrun_met_hastings_mcmc\n.\n\n\n\n\nPlot the Geweke series...\n\n\nsource\n\n\n#\n\n\nDiscuit.plot_autocorrelation\n \n \nFunction\n.\n\n\nplot_autocorrelation(autocorrelation)\n\n\n\n\nParameters\n\n\n\n\nautocorrelation\n     \u2013 The results from a call to \ncompute_autocorrelation\n.\n\n\n\n\nPlot autocorrelation for an MCMC analysis.\n\n\nsource\n\n\n\n\ncustom MCMC\n\n\n#\n\n\nDiscuit.run_custom_mcmc\n \n \nFunction\n.\n\n\nrun_custom_mcmc(model, obs_data, proposal_function, x0, steps = 50000, adapt_period = 10000, prop_param = false, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\nproposal_function\n   \u2013 \nFunction\n for proposing changes to the trajectory. Must have the signature: \ncustom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)\n\n\nx0\n                  \u2013 \nMarkovState\n representing the initial sample and trajectory.\n\n\nsteps\n               \u2013 number of iterations.\n\n\nadapt_period\n        \u2013 burn in period.\n\n\nprop_param\n          \u2013 simulaneously propose changes to parameters. Default: \nfalse\n.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not relevant if \nprop_param = true\n.\n\n\n\n\nRun a custom MCMC analysis. Similar to \nrun_met_hastings_mcmc\n except that the\nproposal_function\n (of type Function) and initial state \nx0\n (of type MarkovState) are user defined.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_custom_mcmc_gelman_diagnostic\n \n \nFunction\n.\n\n\nrun_custom_mcmc_gelman_diagnostic(m_model, obs_data, proposal_function, x0, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\nproposal_function\n   \u2013 \nFunction\n for proposing changes to the trajectory. Must have the signature: \ncustom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)\n\n\nx0\n                  \u2013 vector of \nMarkovState\ns representing the initial samples.\n\n\ninitial_parameters\n  \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.\n\n\nsteps\n               \u2013 number of iterations.\n\n\nadapt_period\n        \u2013 number of discarded samples.\n\n\nprop_param\n          \u2013 simulaneously propose changes to parameters. Default: \nfalse\n.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.\n\n\n\n\nRun n (equal to the number of rows in \ninitial_parameters\n) custom MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_custom_x0\n \n \nFunction\n.\n\n\ngenerate_custom_x0(model, obs_data, parameters, event_times, event_types)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\nparameters\n          \u2013 \nArray\n of initial model parameters.\n\n\nevent_times\n         \u2013 \nArray\n of floats representing the event times.\n\n\nevent_types\n         \u2013 \nArray\n of integer event types.\n\n\n\n\nGenerate an initial \nMarkovState\n for use in a custom MCMC algorithm.\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nDiscuit\n\n\nDiscuit.DiscuitModel\n\n\nDiscuit.GelmanResults\n\n\nDiscuit.MCMCResults\n\n\nDiscuit.Observations\n\n\nDiscuit.SimResults\n\n\nDiscuit.Trajectory\n\n\nDiscuit.compute_autocorrelation\n\n\nDiscuit.generate_custom_x0\n\n\nDiscuit.generate_gaussian_obs_model\n\n\nDiscuit.generate_generic_obs_function\n\n\nDiscuit.generate_model\n\n\nDiscuit.generate_weak_prior\n\n\nDiscuit.get_observations\n\n\nDiscuit.gillespie_sim\n\n\nDiscuit.plot_autocorrelation\n\n\nDiscuit.plot_geweke_series\n\n\nDiscuit.plot_parameter_heatmap\n\n\nDiscuit.plot_parameter_marginal\n\n\nDiscuit.plot_parameter_trace\n\n\nDiscuit.plot_trajectory\n\n\nDiscuit.print_autocorrelation\n\n\nDiscuit.print_gelman_results\n\n\nDiscuit.print_mcmc_results\n\n\nDiscuit.print_observations\n\n\nDiscuit.print_trajectory\n\n\nDiscuit.run_custom_mcmc\n\n\nDiscuit.run_custom_mcmc_gelman_diagnostic\n\n\nDiscuit.run_gelman_diagnostic\n\n\nDiscuit.run_met_hastings_mcmc\n\n\nDiscuit.set_random_seed\n\n\n\n\n\n\nReferences\n\n\nTBA", 
            "title": "Manual"
        }, 
        {
            "location": "/manual/#discuitjl-manual", 
            "text": "See  Discuit.jl examples  for a brief introduction to the package's core functionality.   Discuit.jl manual  Types  Functions  core functionality  model helpers  utilities  visualisation  custom MCMC    Index  References", 
            "title": "Discuit.jl manual"
        }, 
        {
            "location": "/manual/#types", 
            "text": "#  Discuit.DiscuitModel     Type .  DiscuitModel  Fields   model_name           \u2013 string, e,g,  \"SIR\" .  initial_condition    \u2013 initial condition  rate_function        \u2013 event rate function.  m_transition         \u2013 transition matrix.  `observation_function \u2013 observation function, use this to add 'noise' to simulated observations.  prior_density        \u2013 prior density function.  observation_model    \u2013 observation model likelihood function.  t0_index             \u2013 index of the parameter that represents the initial time.  0  if fixed at  0.0 .   A  mutable struct  which represents a DSSCT model (see  Discuit.jl models  for further details).  source  #  Discuit.SimResults     Type .  SimResults  Fields   trajectory       \u2013 a variable of type  Trajectory .  population       \u2013 gives the state of the system after each event.  observations     \u2013 variable of type  Observations .   The results of a simulation.  source  #  Discuit.Trajectory     Type .  Trajectory  Fields   time         \u2013 event times.  event_type   \u2013 event type, index of  model.rate_function .   A single realisation of the model.  source  #  Discuit.Observations     Type .  Observations  Fields   time     \u2013 observation times.  val      \u2013 observation values.   Examples  # pooley dataset\npooley = Observations([20, 40, 60, 80, 100], [0 18; 0 65; 0 70; 0 66; 0 67])  Stores one column vector of observation times and one or more column vectors of observation integer values.  source  #  Discuit.MCMCResults     Type .  MCMCResults  Fields   samples      \u2013 two dimensional array of samples.  mc_accepted  \u2013 proposal accepted  mean         \u2013 sample mean.  covar        \u2013 parameter covariance matrix.   The results of an MCMC analysis including samples; mean; covariance matrix; adaptation period; and results of the Geweke test of stationarity.  source  #  Discuit.GelmanResults     Type .  GelmanResults  Fields   mu       \u2013 between chain sample mean.  sre      \u2013 scale reduction factor estimate.  sre_ll   \u2013 scale reduction factor lower confidence interval.  sre_ul   \u2013 scale reduction factor upper confidence interval.  mcmc     \u2013 array of  MCMCResults   Results of a Gelman Rubin convergence diagnostic including n  MCMCResults  variables;  mu ; and the scale reduction factor estimates ( sre ).  source", 
            "title": "Types"
        }, 
        {
            "location": "/manual/#functions", 
            "text": "This section is organised in three parts:   the main package  core functionality  for working with standard Discuit models  utilities , for loading to and from file  custom MCMC , for running custom algorithms", 
            "title": "Functions"
        }, 
        {
            "location": "/manual/#core-functionality", 
            "text": "#  Discuit.set_random_seed     Function .  set_random_seed(seed)  Examples  set_random_seed(1234)  Does what it says on the tin but only if you give it an integer.  source  #  Discuit.gillespie_sim     Function .  gillespie_sim(model, parameters, tmax = 100.0, num_obs = 5)  Parameters   model        \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  parameters   \u2013 model parameters.  tmax         \u2013 maximum time.  num_obs      \u2013 number of observations to draw,   Run a DGA simulation on  model . Returns a SimResults containing the trajectory and observations data.  source  #  Discuit.run_met_hastings_mcmc     Function .  run_met_hastings_mcmc(model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  initial_parameters   \u2013 initial model parameters (i.e. sample).  steps                \u2013 number of iterations.  mbp                  \u2013 model based proposals (MBP). Set  mbp = false  for standard proposals.  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.   Run an MCMC analysis based on  model  and  obs_data  of type  Observations . The number of samples obtained is equal to  steps  -  adapt_period .  source  #  Discuit.run_gelman_diagnostic     Function .  run_gelman_diagnostic(m_model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  initial_parameters   \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.  steps                \u2013 number of iterations.  adapt_period         \u2013 number of discarded samples.  mbp                  \u2013 model based proposals (MBP). Set  mbp = false  for standard proposals.  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.   Run n (equal to the number of rows in  initial_parameters )  MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.  source  #  Discuit.compute_autocorrelation     Function .  compute_autocorrelation(mcmc, lags = 200)  Parameters   mcmc     \u2013  MCMCResults  variable.  lags     \u2013 the number of lags to compute. Default: 200.   Compute autocorrelation R for a single Markov chain. Autocorrelation can be used to help determine how well the algorithm mixed by using  compute_autocorrelation(rs.mcmc) . The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:   \nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}   for any given lag  l .  source  compute_autocorrelation(mcmc, lags = 200)  Parameters   mcmc     \u2013 an array of  MCMCResults  variables.  lags     \u2013 the number of lags to compute. Default: 200.   Compute autocorrelation R' for a two or more Markov chains. The formula for multiple chains is given by:   \nR^{\\prime}_l = \\frac{\\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]}{\\sigma^2_b}    \n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]   where .  source", 
            "title": "core functionality"
        }, 
        {
            "location": "/manual/#model-helpers", 
            "text": "Discuit.jl  includes tools for generating components which can help minimise the amount of work required to generate customised  DiscuitModel s, including  generate_model(...)  which is used to access a library of pre defined  Discuit.jl models .  #  Discuit.generate_generic_obs_function     Function .  generate_generic_obs_function()  Generates a simple observation function for use in a  DiscuitModel . Not very realistic...  source  #  Discuit.generate_weak_prior     Method .  generate_weak_prior(n)  Parameters   n    \u2013 the number of parameters in the model.   Examples  generate_weak_prior(1)  Generate a \"weak\" prior density function, where  n  is the number of parameters in the model.  source  #  Discuit.generate_gaussian_obs_model     Function .  generate_gaussian_obs_model(n, \u03c3 = 2.0)  Parameters   n    \u2013 the number of discrete states in the model.  \u03c3    \u2013 observation error.   test latex eqn:   \n\frac{n!}{k!(n - k)!} = \binom{n}{k}   Examples  p = generate_weak_prior(1)  Generate a Gaussian observation model for a model with  n  states. Optionally specify observation error  \u03c3 .  source  #  Discuit.generate_model     Function .  generate_model(model_name, initial_condition, \u03c3 = 2.0)  Parameters   model_name           \u2013 the model, e.g. \"SI\"; \"SIR\"; \"SEIR\"; etc  initial_condition    \u2013 initial condition.  \u03c3                    \u2013 observation error.   model_name   options   \"SI\"  \"SIR\"  \"SIS\"  \"SEI\"  \"SEIR\"  \"SEIS\"  \"SEIRS\"  \"PREDPREY\"  \"ROSSMAC\"   Examples  generate_model( SIS , [100,1])  Generates a  DiscuitModel . Optionally specify observation error  \u03c3 .  source", 
            "title": "model helpers"
        }, 
        {
            "location": "/manual/#utilities", 
            "text": "#  Discuit.print_trajectory     Function .  print_trajectory(model, sim_results, fpath)  Parameters   model        \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  sim_results  \u2013  SimResults  variable.  fpath        \u2013 the destination file path.   Save an augmented trajectory from a variable of type  SimResults  (i.e. from a call to  gillespie_sim , see  Simulation ) to the file  fpath , e.g. \"./out/sim.csv\".  source  #  Discuit.print_observations     Function .  print_observations(obs_data, fpath)  Parameters   obs_data     \u2013  Observations  data.  fpath        \u2013 the destination file path.   Save a set of observations (e.g. from a  SimResults  obtained by a call to  gillespie_sim  to the file  fpath , e.g. \"./out/obs.csv\".  source  #  Discuit.get_observations     Function .  get_observations(source)  Parameters   source       \u2013  Array ,  DataFrame  or filepath (i.e.  String ) containing the data (with times in the first column).   Create and return a variable of type  Observations  based on a two dimensional array,  DataFrame  or file location.  source  #  Discuit.print_mcmc_results     Function .  print_mcmc_results(mcmc, dpath)  Parameters   results  \u2013  MCMCResults  variable.  dpath    \u2013 the path of the directory where the results will be saved.   Save the results from a call to  run_met_hastings_mcmc  or  run_custom_mcmc  to the directory  dpath , e.g. \"./out/mcmc/\".  source  #  Discuit.print_gelman_results     Function .  print_gelman_results(results::GelmanResults, dpath::String)  Parameters   results  \u2013  GelmanResults  variable.  dpath    \u2013 the path of the directory where the results will be saved.   Save the results from a call to  run_gelman_diagnostic  to the directory  dpath , e.g. \"./out/gelman/\".  source  #  Discuit.print_autocorrelation     Function .  print_autocorrelation(autocorrelation, fpath)  Parameters   autocorrelation  \u2013 the results of a call to  compute_autocorrelation .  fpath            \u2013 the file path of the destination file.   Save the results from a call to  compute_autocorrelation  to the file  fpath , e.g. \"./out/ac.csv\".  source", 
            "title": "utilities"
        }, 
        {
            "location": "/manual/#visualisation", 
            "text": "#  Discuit.plot_trajectory     Function .  plot_trajectory(x)  Parameters   x        \u2013  SimResults , i.e. from a call to  gillespie_sim .   Plot the trajectory of a a DGA simulation on  model  using  UnicodePlots.jl .  source  #  Discuit.plot_parameter_trace     Function .  plot_parameter_trace(mcmc, parameter)  Parameters   mcmc         \u2013  MCMCResults , e.g. from a call to  run_met_hastings_mcmc .  parameter    \u2013 the index of the model parameter to be plotted.   Trace plot of samples from an MCMC analysis for a given model  parameter  using  UnicodePlots.jl .  source  plot_parameter_trace(mcmc, parameter)  Parameters   mcmc         \u2013 array of  MCMCResults , e.g. from a call to  run_gelman_diagnostic .  parameter    \u2013 the index of the model parameter to be plotted.   Trace plot of samples from  n  MCMC analyses for a given model  parameter  using  UnicodePlots.jl .  source  #  Discuit.plot_parameter_marginal     Function .  plot_parameter_marginal(mcmc, parameter)  Parameters   mcmc         \u2013  MCMCResults , e.g. from a call to  run_met_hastings_mcmc .  parameter    \u2013 the index of the model parameter to be plotted.   Plot the marginal distribution of samples from an MCMC analysis for a given model  parameter  using  UnicodePlots.jl .  source  #  Discuit.plot_parameter_heatmap     Function .  plot_parameter_heatmap(mcmc, x_parameter, y_parameter)  Parameters   mcmc         \u2013  MCMCResults , e.g. from a call to  run_met_hastings_mcmc .  x_parameter    \u2013 the index of the model parameter to be plotted on the x axis.  y_parameter    \u2013 the index of the model parameter to be plotted on the y axis.   Plot the marginal distribution of samples from an MCMC analysis for two model parameters using  UnicodePlots.jl .  source  #  Discuit.plot_geweke_series     Function .  plot_geweke_series(mcmc)  Parameters   mcmc         \u2013  MCMCResults , e.g. from a call to  run_met_hastings_mcmc .   Plot the Geweke series...  source  #  Discuit.plot_autocorrelation     Function .  plot_autocorrelation(autocorrelation)  Parameters   autocorrelation      \u2013 The results from a call to  compute_autocorrelation .   Plot autocorrelation for an MCMC analysis.  source", 
            "title": "visualisation"
        }, 
        {
            "location": "/manual/#custom-mcmc", 
            "text": "#  Discuit.run_custom_mcmc     Function .  run_custom_mcmc(model, obs_data, proposal_function, x0, steps = 50000, adapt_period = 10000, prop_param = false, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  proposal_function    \u2013  Function  for proposing changes to the trajectory. Must have the signature:  custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)  x0                   \u2013  MarkovState  representing the initial sample and trajectory.  steps                \u2013 number of iterations.  adapt_period         \u2013 burn in period.  prop_param           \u2013 simulaneously propose changes to parameters. Default:  false .  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not relevant if  prop_param = true .   Run a custom MCMC analysis. Similar to  run_met_hastings_mcmc  except that the proposal_function  (of type Function) and initial state  x0  (of type MarkovState) are user defined.  source  #  Discuit.run_custom_mcmc_gelman_diagnostic     Function .  run_custom_mcmc_gelman_diagnostic(m_model, obs_data, proposal_function, x0, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  proposal_function    \u2013  Function  for proposing changes to the trajectory. Must have the signature:  custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)  x0                   \u2013 vector of  MarkovState s representing the initial samples.  initial_parameters   \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.  steps                \u2013 number of iterations.  adapt_period         \u2013 number of discarded samples.  prop_param           \u2013 simulaneously propose changes to parameters. Default:  false .  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.   Run n (equal to the number of rows in  initial_parameters ) custom MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.  source  #  Discuit.generate_custom_x0     Function .  generate_custom_x0(model, obs_data, parameters, event_times, event_types)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  parameters           \u2013  Array  of initial model parameters.  event_times          \u2013  Array  of floats representing the event times.  event_types          \u2013  Array  of integer event types.   Generate an initial  MarkovState  for use in a custom MCMC algorithm.  source", 
            "title": "custom MCMC"
        }, 
        {
            "location": "/manual/#index", 
            "text": "Discuit  Discuit.DiscuitModel  Discuit.GelmanResults  Discuit.MCMCResults  Discuit.Observations  Discuit.SimResults  Discuit.Trajectory  Discuit.compute_autocorrelation  Discuit.generate_custom_x0  Discuit.generate_gaussian_obs_model  Discuit.generate_generic_obs_function  Discuit.generate_model  Discuit.generate_weak_prior  Discuit.get_observations  Discuit.gillespie_sim  Discuit.plot_autocorrelation  Discuit.plot_geweke_series  Discuit.plot_parameter_heatmap  Discuit.plot_parameter_marginal  Discuit.plot_parameter_trace  Discuit.plot_trajectory  Discuit.print_autocorrelation  Discuit.print_gelman_results  Discuit.print_mcmc_results  Discuit.print_observations  Discuit.print_trajectory  Discuit.run_custom_mcmc  Discuit.run_custom_mcmc_gelman_diagnostic  Discuit.run_gelman_diagnostic  Discuit.run_met_hastings_mcmc  Discuit.set_random_seed", 
            "title": "Index"
        }, 
        {
            "location": "/manual/#references", 
            "text": "TBA", 
            "title": "References"
        }
    ]
}