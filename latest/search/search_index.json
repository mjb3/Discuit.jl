{
    "docs": [
        {
            "location": "/", 
            "text": "Discuit.jl documentation\n\n\nFast parameter inference for discrete state space continuous time (DSSCT) models in Julia.\n\n\n\n\nPlease note that this package is still in development.\n\n\n\n\n\n\nPackage Features\n\n\n#\n\n\nDiscuit\n \n \nModule\n.\n\n\nDiscuit is a package for:\n\n\n\n\nUser defined DSSCT models.\n\n\nPre programmed with many well known epidemiological models.\n\n\nData augmented Markov chain Monte Carlo (MCMC).\n\n\nExact simulation using Gillespie's algorithm.\n\n\nAutomated autocorrelation; Geweke and Gelman-Rubin diagnostics.\n\n\nDeveloped for Julia \n1.0\n.\n\n\nAuthor: Martin Burke (martin.burke@bioss.ac.uk)\n\n\nDate: 2018-08-22\n\n\n\n\nsource\n\n\n\n\nContents\n\n\n\n\nDiscuit.jl models\n\n\nModel builder\n\n\nClassic Kermack-McKendrick models\n\n\nLatent Kermack-McKendrick models\n\n\nMiscellaneous\n\n\nReferences\n\n\n\n\n\n\nDiscuit.jl examples\n\n\nSIS model\n\n\nCustom MCMC\n\n\n\n\n\n\nDiscuit.jl manual\n\n\nContents\n\n\nTypes\n\n\nFunctions\n\n\nIndex\n\n\nReferences\n\n\n\n\n\n\nDiscuit.jl documentation\n\n\nPackage Features\n\n\nContents\n\n\nInstallation\n\n\nUsage\n\n\ntest\n\n\n\n\n\n\n\n\n\n\nInstallation\n\n\nThe package can be installed by typing \n]\n in the REPL to enter the Pkg mode and running:\n\n\npkg\n add https://github.com/mjb3/Discuit.jl\n\n\n\n\n\n\nUsage\n\n\nThe \nDiscuit.jl examples\n section provides enough code to get up and running. A more detailed guide to the pre defined models is available in the \nDiscuit.jl models\n section. Further information regarding the packages other functionality can be found in the \nDiscuit.jl manual\n.\n\n\n\n\ntest\n\n\nThe autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:\n\n\n\n\n\nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}\n\n\n\n\n\nfor any given lag \nl\n. The modified formula for multiple chains is given by:\n\n\n\n\n\nR^{\\prime}_l = \\frac{x}{\\sigma^2_b}\n\n\n\n\n\n\n\n\n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]\n\n\n\n\n\n\n\n\nx = \\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]\n\n\n\n\n\n\n\n\nx = \\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]\n\n\n\n\n\n\n\n\nx = \\textrm{E} [(X_i - \\bar{X}_b) y]\n\n\n\n\n\n\n\n\ny = (X_{i+l} - \\bar{X}_b)", 
            "title": "Introduction"
        }, 
        {
            "location": "/#discuitjl-documentation", 
            "text": "Fast parameter inference for discrete state space continuous time (DSSCT) models in Julia.   Please note that this package is still in development.", 
            "title": "Discuit.jl documentation"
        }, 
        {
            "location": "/#package-features", 
            "text": "#  Discuit     Module .  Discuit is a package for:   User defined DSSCT models.  Pre programmed with many well known epidemiological models.  Data augmented Markov chain Monte Carlo (MCMC).  Exact simulation using Gillespie's algorithm.  Automated autocorrelation; Geweke and Gelman-Rubin diagnostics.  Developed for Julia  1.0 .  Author: Martin Burke (martin.burke@bioss.ac.uk)  Date: 2018-08-22   source", 
            "title": "Package Features"
        }, 
        {
            "location": "/#contents", 
            "text": "Discuit.jl models  Model builder  Classic Kermack-McKendrick models  Latent Kermack-McKendrick models  Miscellaneous  References    Discuit.jl examples  SIS model  Custom MCMC    Discuit.jl manual  Contents  Types  Functions  Index  References    Discuit.jl documentation  Package Features  Contents  Installation  Usage  test", 
            "title": "Contents"
        }, 
        {
            "location": "/#installation", 
            "text": "The package can be installed by typing  ]  in the REPL to enter the Pkg mode and running:  pkg  add https://github.com/mjb3/Discuit.jl", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The  Discuit.jl examples  section provides enough code to get up and running. A more detailed guide to the pre defined models is available in the  Discuit.jl models  section. Further information regarding the packages other functionality can be found in the  Discuit.jl manual .", 
            "title": "Usage"
        }, 
        {
            "location": "/#test", 
            "text": "The autocorrelation function for a single Markov chain is implemented in Discuit using the standard formula:   \nR_l  = \\frac{\\textrm{E} [(X_i - \\bar{X})(X_{i+l} - \\bar{X})]}{\\sigma^2}   for any given lag  l . The modified formula for multiple chains is given by:   \nR^{\\prime}_l = \\frac{x}{\\sigma^2_b}    \n\\sigma^2_b = \\textrm{E} [(X_i - \\bar{X}_b)^2]    \nx = \\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]    \nx = \\textrm{E} [ (X_i - \\bar{X}_b) ( X_{i + l} - \\bar{X}_b ) ]    \nx = \\textrm{E} [(X_i - \\bar{X}_b) y]    \ny = (X_{i+l} - \\bar{X}_b)", 
            "title": "test"
        }, 
        {
            "location": "/examples/", 
            "text": "Discuit.jl examples\n\n\nThe following examples provide a flavour of Discuit's core functionality. See the \nDiscuit.jl manual\n for more detailed instructions.\n\n\n\n\nSIS model\n\n\nThe following example is based on that published by Pooley et al. in 2015 in the paper that introduces the model based proposal method. We could use \ngenerate_model(\"SIS\", [100,1])\n to generate the model but constructing it manually is a helpful exercise for getting to know the package. We start by examining \nDiscuitModel\n in the package documentation:\n\n\njulia\n using Discuit;\n\n\n\n\nNow that we know the necessary parameters for defining a model we can begin by defining a rate function. Note that the correct signature must be used in order for it to be compatible with the package:\n\n\njulia\n function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n           output[1] = parameters[1] * population[1] * population[2]\n           output[2] = parameters[2] * population[2]\n       end\nsis_rf (generic function with 1 method)\n\n\n\n\nNext we define a simple observation function, again with the correct signature:\n\n\njulia\n obs_fn(population::Array{Int64, 1}) = population\nobs_fn (generic function with 1 method)\n\n\n\n\nNaturally we choose the same prior distribution as Pooley so that we can compare results. The return type must be Float.\n\n\njulia\n function weak_prior(parameters::Array{Float64, 1})\n           parameters[1] \n 0.0 || return 0.0\n           parameters[2] \n 0.0 || return 0.0\n           return 1.0\n       end\nweak_prior (generic function with 1 method)\n\n\n\n\nFinally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation \n2\n:\n\n\njulia\n function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})\n           obs_err = 2\n           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))\n           tmp2 = 2 * obs_err * obs_err\n           obs_diff = y[2] - population[2]\n           return tmp1 - ((obs_diff * obs_diff) / tmp2)\n       end\nsi_gaussian (generic function with 1 method)\n\n\n\n\nWe can now define a model. The three parameters declared inline are the transition matrix; an optional index for the t0 parameter (ignore for now); and the initial condition which represents the state of the population at the origin of each trajectory:\n\n\njulia\n model = DiscuitModel(\nSIS\n, sis_rf, [-1 1; 1 -1], 0, [100, 1], obs_fn, weak_prior, si_gaussian);\n\n\n\n\n\n\nSimulation\n\n\nAlthough our main goal is to replicate the analysis of Pooley et al. we can also run a simulation using the \ngillespie_sim\n function.\n\n\njulia\n xi = gillespie_sim(model, [0.003, 0.1]);\nrunning simulation...\n finished (1037 events).\n\n\n\n\nWe can also visualise the results using the corresponding R package: rDiscuit. ADD LINK\n\n\n\n\n\n\nMCMC\n\n\nRunning an MCMC analysis based on a set of observations data is simple. TBC...\n\n\njulia\n obs = Observations([20, 40, 60, 80, 100], [0 18; 0 65; 0 70; 0 66; 0 67]);\n\njulia\n rs = run_met_hastings_mcmc(model, obs, [0.003, 0.1]);\nrunning MCMC...\n finished (sample \u03bc = [0.0033639, 0.115281]).\n\n\n\n\nPlaceholder for MCMC output.\n\n\n\n\n\n\nDiagnostic\n\n\n\n\nGeweke test of stationarity\n\n\nThe Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain. It is given by:\n\n\nNEED TO ADD CITATIONS: geweke\nevaluating\n1992,cowles\nmarkov\n1996\n\n\n\n\n\nz = \\frac{\\bar{\\theta}_{i, \\alpha} - \\bar{\\theta}_{i, \\beta}}{\\sqrt{Var(\\theta_{i, \\alpha})+Var(\\theta_{i, \\beta})})}\n\n\n\n\n\njulia\n rs.geweke\n([2000, 4000, 6000, 8000, 10000, 12000, 14000, 16000, 18000, 20000], [0.0591316 0.244598; 0.126286 0.351017; \u2026 ; 0.197914 0.330827; -0.768425 -0.723813])\n\n\n\n\n\n\n\n\nGelman-Rubin convergence diagnostic\n\n\nThe Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance. The \nestimated scale reduction\n statistic (sometimes referred to as \npotential scale reduction factor\n) is calculated for each parameter in the model.\n\n\nNEED TO ADD CITATIONS: gelman\ninference\n1992,gelman\nbayesian\n2014\n\n\nLet $\\bar{\\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\\theta$, within chain variance between chain variance respectively for $M$ Markov chains:\n\n\n\n\n\nW = \\frac{1}{M} \\sum_{i = 1}^M \\sigma^2_i\n\n\n\n\n\n\n\n\nB = \\frac{N}{M - 1} \\sum_{i = 1}^M (\\hat{\\theta}_i - \\hat{\\theta})^2\n\n\n\n\n\nThe estimated scale reduction statistic is given by:\n\n\n\n\n\nR = \\sqrt{\\frac{d + 3}{d + 1} \\frac{N-1}{N} + (\\frac{M+1}{MN} \\frac{B}{W})}\n\n\n\n\n\nwhere the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.\n\n\njulia\n rs = run_gelman_diagnostic(model, obs, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);\nrunning gelman diagnostic...\n chain 1 complete.\n chain 2 complete.\n chain 3 complete.\n finished (sample \u03bc = [0.00313563, 0.104747]).\n\n\n\n\n\n\nAutocorrelation\n\n\nAutocorrelation can be used to help determine how well the algorithm mixed by using \ncompute_autocorrelation(rs.mcmc)\n.\n\n\nNEED TO ADD autocorr definition and image ...\n\n\n\n\n\n\nCustom MCMC\n\n\nSome situations...\n\n\nFirst we generate a standard \nSIR\n model and set the \nt0_index = 3\n.\n\n\njulia\n model = generate_model(\nSIR\n, [119, 1, 0]);\n\njulia\n model.t0_index = 3;\n\n\n\n\nNext we define the \"medium\" prior used by O'Neill and Roberts, with some help from the \nDistributions.jl\n package:\n\n\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n\u001b[?25l\u001b[2K\u001b[?25h Resolving package versions...\n  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`\n  [31c24e10] + Distributions v0.16.4\n  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`\n [no changes]\n\njulia\n using Distributions;\n\njulia\n p1 = Gamma(10, 0.0001);\n\njulia\n p2 = Gamma(10, 0.01);\n\njulia\n function prior_density(parameters::Array{Float64, 1})\n           return parameters[3] \n 0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0\n       end\nprior_density (generic function with 1 method)\n\njulia\n model.prior_density = prior_density;\n\n\n\n\nThe observation model is replaced with one that returns \nlog(1)\n since we will only propose sequences consitent with the observed recoveries and $\\pi(\\xi | \\theta)$ is evaluated automatically by Discuit):\n\n\njulia\n observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0\nobservation_model (generic function with 1 method)\n\njulia\n model.observation_model = observation_model;\n\n\n\n\nNext we define an array \nt\n to contain the recovery times reported by O'Neill and Roberts and a simple \nObservations\n variable which consists of the maximum event time and an empty two dimensional array:\n\n\njulia\n t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];\n\njulia\n y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))\nObservations([67.0], [140200647749888])\n\n\n\n\nWe also need to define an initial state using the \ngenerate_custom_x0\n function using some parameter values and a vector of event times and corresponding event types, consistent with \nt\n:\n\n\njulia\n evt_tm = Float64[];\n\njulia\n evt_tp = Int64[];\n\njulia\n for i in 1:(length(t) - 1)# infections at arbitrary t \n t0\n           push!(evt_tm, -4.0)\n           push!(evt_tp, 1)\n       end\n\njulia\n for i in eachindex(t)     # recoveries\n           push!(evt_tm, t[i])\n           push!(evt_tp, 2)\n       end\n\njulia\n x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);\n\n\n\n\nThe final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit).\n\n\njulia\n function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)\n           t0 = xf_parameters.value[model.t0_index]\n           ## move\n           seq_f = deepcopy(xi.trajectory)\n           # choose event and define new one\n           evt_i = rand(1:length(xi.trajectory.time))\n           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()\n           evt_tp = xi.trajectory.event_type[evt_i]\n           # remove old one\n           splice!(seq_f.time, evt_i)\n           splice!(seq_f.event_type, evt_i)\n           # add new one\n           if evt_tm \n seq_f.time[end]\n               push!(seq_f.time, evt_tm)\n               push!(seq_f.event_type, evt_tp)\n           else\n               for i in eachindex(seq_f.time)\n                   if seq_f.time[i] \n evt_tm\n                       insert!(seq_f.time, i, evt_tm)\n                       insert!(seq_f.event_type, i, evt_tp)\n                       break\n                   end\n               end\n           end\n           # compute ln g(x)\n           prop_lk = 1.0\n           ## evaluate full likelihood for trajectory proposal and return\n           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)\n       end # end of std proposal function\ncustom_proposal (generic function with 1 method)\n\n\n\n\nWe can now run the MCMC analysis:\n\n\njulia\n rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);\nrunning custom MCMC...\n finished (sample \u03bc = [0.000993775, 0.104761, -3.18788]).\n\n\n\n\nNeed to add commentary:\n\n\n\n\n\n\n\n\nlink to \nset_random_seed(seed::Int64)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#discuitjl-examples", 
            "text": "The following examples provide a flavour of Discuit's core functionality. See the  Discuit.jl manual  for more detailed instructions.", 
            "title": "Discuit.jl examples"
        }, 
        {
            "location": "/examples/#sis-model", 
            "text": "The following example is based on that published by Pooley et al. in 2015 in the paper that introduces the model based proposal method. We could use  generate_model(\"SIS\", [100,1])  to generate the model but constructing it manually is a helpful exercise for getting to know the package. We start by examining  DiscuitModel  in the package documentation:  julia  using Discuit;  Now that we know the necessary parameters for defining a model we can begin by defining a rate function. Note that the correct signature must be used in order for it to be compatible with the package:  julia  function sis_rf(output::Array{Float64, 1}, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n           output[1] = parameters[1] * population[1] * population[2]\n           output[2] = parameters[2] * population[2]\n       end\nsis_rf (generic function with 1 method)  Next we define a simple observation function, again with the correct signature:  julia  obs_fn(population::Array{Int64, 1}) = population\nobs_fn (generic function with 1 method)  Naturally we choose the same prior distribution as Pooley so that we can compare results. The return type must be Float.  julia  function weak_prior(parameters::Array{Float64, 1})\n           parameters[1]   0.0 || return 0.0\n           parameters[2]   0.0 || return 0.0\n           return 1.0\n       end\nweak_prior (generic function with 1 method)  Finally, we define an observation likelihood model. Again, we use the same as Pooley, with observation errors normally distributed around the true value with standard deviation  2 :  julia  function si_gaussian(y::Array{Int64, 1}, population::Array{Int64, 1})\n           obs_err = 2\n           tmp1 = log(1 / (sqrt(2 * pi) * obs_err))\n           tmp2 = 2 * obs_err * obs_err\n           obs_diff = y[2] - population[2]\n           return tmp1 - ((obs_diff * obs_diff) / tmp2)\n       end\nsi_gaussian (generic function with 1 method)  We can now define a model. The three parameters declared inline are the transition matrix; an optional index for the t0 parameter (ignore for now); and the initial condition which represents the state of the population at the origin of each trajectory:  julia  model = DiscuitModel( SIS , sis_rf, [-1 1; 1 -1], 0, [100, 1], obs_fn, weak_prior, si_gaussian);", 
            "title": "SIS model"
        }, 
        {
            "location": "/examples/#simulation", 
            "text": "Although our main goal is to replicate the analysis of Pooley et al. we can also run a simulation using the  gillespie_sim  function.  julia  xi = gillespie_sim(model, [0.003, 0.1]);\nrunning simulation...\n finished (1037 events).  We can also visualise the results using the corresponding R package: rDiscuit. ADD LINK", 
            "title": "Simulation"
        }, 
        {
            "location": "/examples/#mcmc", 
            "text": "Running an MCMC analysis based on a set of observations data is simple. TBC...  julia  obs = Observations([20, 40, 60, 80, 100], [0 18; 0 65; 0 70; 0 66; 0 67]);\n\njulia  rs = run_met_hastings_mcmc(model, obs, [0.003, 0.1]);\nrunning MCMC...\n finished (sample \u03bc = [0.0033639, 0.115281]).  Placeholder for MCMC output.", 
            "title": "MCMC"
        }, 
        {
            "location": "/examples/#diagnostic", 
            "text": "", 
            "title": "Diagnostic"
        }, 
        {
            "location": "/examples/#geweke-test-of-stationarity", 
            "text": "The Geweke statistic tests for non-stationarity by comparing the mean and variance for two sections of the Markov chain. It is given by:  NEED TO ADD CITATIONS: geweke evaluating 1992,cowles markov 1996   \nz = \\frac{\\bar{\\theta}_{i, \\alpha} - \\bar{\\theta}_{i, \\beta}}{\\sqrt{Var(\\theta_{i, \\alpha})+Var(\\theta_{i, \\beta})})}   julia  rs.geweke\n([2000, 4000, 6000, 8000, 10000, 12000, 14000, 16000, 18000, 20000], [0.0591316 0.244598; 0.126286 0.351017; \u2026 ; 0.197914 0.330827; -0.768425 -0.723813])", 
            "title": "Geweke test of stationarity"
        }, 
        {
            "location": "/examples/#gelman-rubin-convergence-diagnostic", 
            "text": "The Gelman-Rubin diagnostic is designed to diagnose convergence of two or more Markov chains by comparing within chain variance to between chain variance. The  estimated scale reduction  statistic (sometimes referred to as  potential scale reduction factor ) is calculated for each parameter in the model.  NEED TO ADD CITATIONS: gelman inference 1992,gelman bayesian 2014  Let $\\bar{\\theta}$, $W$ and $B$ be vectors of length $P$ representing the mean of model parameters $\\theta$, within chain variance between chain variance respectively for $M$ Markov chains:   \nW = \\frac{1}{M} \\sum_{i = 1}^M \\sigma^2_i    \nB = \\frac{N}{M - 1} \\sum_{i = 1}^M (\\hat{\\theta}_i - \\hat{\\theta})^2   The estimated scale reduction statistic is given by:   \nR = \\sqrt{\\frac{d + 3}{d + 1} \\frac{N-1}{N} + (\\frac{M+1}{MN} \\frac{B}{W})}   where the first quantity on the RHS adjusts for sampling variance and $d$ is degrees of freedom estimated using the method of moments. For a valid test of convergence the Gelman-Rubin requires two or more Markov chains with over dispersed target values relative to the target distribution. A matrix of such values is therefore required in place of the vector representing the initial values an McMC analysis when calling the function in Discuit, with the $i^{th}$ row vector used to initialise the $i^{th}$ Markov chain.  julia  rs = run_gelman_diagnostic(model, obs, [0.0025 0.08; 0.003 0.12; 0.0035 0.1]);\nrunning gelman diagnostic...\n chain 1 complete.\n chain 2 complete.\n chain 3 complete.\n finished (sample \u03bc = [0.00313563, 0.104747]).", 
            "title": "Gelman-Rubin convergence diagnostic"
        }, 
        {
            "location": "/examples/#autocorrelation", 
            "text": "Autocorrelation can be used to help determine how well the algorithm mixed by using  compute_autocorrelation(rs.mcmc) .  NEED TO ADD autocorr definition and image ...", 
            "title": "Autocorrelation"
        }, 
        {
            "location": "/examples/#custom-mcmc", 
            "text": "Some situations...  First we generate a standard  SIR  model and set the  t0_index = 3 .  julia  model = generate_model( SIR , [119, 1, 0]);\n\njulia  model.t0_index = 3;  Next we define the \"medium\" prior used by O'Neill and Roberts, with some help from the  Distributions.jl  package:    Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n\u001b[?25l\u001b[2K\u001b[?25h Resolving package versions...\n  Updating `~/build/mjb3/Discuit.jl/docs/Project.toml`\n  [31c24e10] + Distributions v0.16.4\n  Updating `~/build/mjb3/Discuit.jl/docs/Manifest.toml`\n [no changes]\n\njulia  using Distributions;\n\njulia  p1 = Gamma(10, 0.0001);\n\njulia  p2 = Gamma(10, 0.01);\n\njulia  function prior_density(parameters::Array{Float64, 1})\n           return parameters[3]   0.0 ? pdf(p1, parameters[1]) * pdf(p2, parameters[2]) * (0.1 * exp(0.1 * parameters[3])) : 0.0\n       end\nprior_density (generic function with 1 method)\n\njulia  model.prior_density = prior_density;  The observation model is replaced with one that returns  log(1)  since we will only propose sequences consitent with the observed recoveries and $\\pi(\\xi | \\theta)$ is evaluated automatically by Discuit):  julia  observation_model(y::Array{Int, 1}, population::Array{Int, 1}) = 0.0\nobservation_model (generic function with 1 method)\n\njulia  model.observation_model = observation_model;  Next we define an array  t  to contain the recovery times reported by O'Neill and Roberts and a simple  Observations  variable which consists of the maximum event time and an empty two dimensional array:  julia  t = [0.0, 13.0, 20.0, 22.0, 25.0, 25.0, 25.0, 26.0, 30.0, 35.0, 38.0, 40.0, 40.0, 42.0, 42.0, 47.0, 50.0, 51.0, 55.0, 55.0, 56.0, 57.0, 58.0, 60.0, 60.0, 61.0, 66.0];\n\njulia  y = Observations([67.0], Array{Int64, 2}(undef, 1, 1))\nObservations([67.0], [140200647749888])  We also need to define an initial state using the  generate_custom_x0  function using some parameter values and a vector of event times and corresponding event types, consistent with  t :  julia  evt_tm = Float64[];\n\njulia  evt_tp = Int64[];\n\njulia  for i in 1:(length(t) - 1)# infections at arbitrary t   t0\n           push!(evt_tm, -4.0)\n           push!(evt_tp, 1)\n       end\n\njulia  for i in eachindex(t)     # recoveries\n           push!(evt_tm, t[i])\n           push!(evt_tp, 2)\n       end\n\njulia  x0 = generate_custom_x0(model, y, [0.001, 0.1, -4.0], evt_tm, evt_tp);  The final step before we run our analysis is to define the algorithm which will propose changes to augmented data (parameter proposals are automatically configured by Discuit).  julia  function custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal)\n           t0 = xf_parameters.value[model.t0_index]\n           ## move\n           seq_f = deepcopy(xi.trajectory)\n           # choose event and define new one\n           evt_i = rand(1:length(xi.trajectory.time))\n           evt_tm = xi.trajectory.event_type[evt_i] == 1 ? (rand() * (model.obs_data.time[end] - t0)) + t0 : floor(xi.trajectory.time[evt_i]) + rand()\n           evt_tp = xi.trajectory.event_type[evt_i]\n           # remove old one\n           splice!(seq_f.time, evt_i)\n           splice!(seq_f.event_type, evt_i)\n           # add new one\n           if evt_tm   seq_f.time[end]\n               push!(seq_f.time, evt_tm)\n               push!(seq_f.event_type, evt_tp)\n           else\n               for i in eachindex(seq_f.time)\n                   if seq_f.time[i]   evt_tm\n                       insert!(seq_f.time, i, evt_tm)\n                       insert!(seq_f.event_type, i, evt_tp)\n                       break\n                   end\n               end\n           end\n           # compute ln g(x)\n           prop_lk = 1.0\n           ## evaluate full likelihood for trajectory proposal and return\n           return MarkovState(xi.parameters, seq_f, compute_full_log_like(model, xi.parameters.value, seq_f), prop_lk, 3)\n       end # end of std proposal function\ncustom_proposal (generic function with 1 method)  We can now run the MCMC analysis:  julia  rs = run_custom_mcmc(model, y, custom_proposal, x0, 120000, 20000);\nrunning custom MCMC...\n finished (sample \u03bc = [0.000993775, 0.104761, -3.18788]).  Need to add commentary:     link to  set_random_seed(seed::Int64)", 
            "title": "Custom MCMC"
        }, 
        {
            "location": "/models/", 
            "text": "Discuit.jl models\n\n\nDiscuit comes with a number of well known, mostly epidemiological models pre defined. This section describes the models and how to use them.\n\n\n\n\nModel builder\n\n\nPre defined models can be invoked by calling:\n\n\ngenerate_model(model_name, initial_condition, \u03c3 = 2.0)\n\n\n\n\n Examples \n\n\nmodel = generate_model(\nSIS\n, [100, 1]]);\nmodel = generate_model(\nSEIR\n, [100, 0, 1, 0]], 1.0)\n\n\n\n\n\n\nDefaults\n\n\nDiscuit.jl models\n are \nmutable struct\ns so it is convenient to generate pre defined with default values for most things and allow the user to overwrite as required. Only the 'model*name' and \ninitial*condition\nare required to call\ngenerate_model\n. The following gives an overview of important defaults that the user should note before proceeding with their analysis.\n\n\n\n\nObservation function\n\n\nThe default \nmodel.obs_function\n is YET TO BE DETERMINED...\n\n\n\n\nObservation likelihood model\n\n\nThe default \nmodel.observation_model\n is Gaussian with observation error \n\u03c3 = 2.0\n by default, which can be changed by providing an optional third parameter to \ngenerate_model\n per the example above,\n\n\nADD EQNS\n\n\n\n\nPrior density function\n\n\nThe default \nmodel.prior\n density function is weak, e.g. in a simple two parameter model it is equivalent to:\n\n\nfunction weak_prior(parameters::Array{Float64, 1})\n    parameters[1] \n 0.0 || return 0.0\n    parameters[2] \n 0.0 || return 0.0\n    return 1.0\nend\n\n\n\n\nNote that all models generated by the ADD XREF have \nt0_index = 0\n by default and that changing this parameter will likely require replacing the the density with something like:\n\n\nfunction weak_prior(parameters::Array{Float64, 1})\n    parameters[1] \n 0.0 || return 0.0\n    parameters[2] \n 0.0 || return 0.0\n    parameters[3] \n 0.0 || return 0.0\n    return 1.0\nend\n\n\n\n\nwhere \nparameters[3]\n is designated as the, e.g. initial infection, which is assumed to have taken place prior to e.g. the initial observation at t = 0.0. ADD LATEX...\n\n\n\n\nClassic Kermack-McKendrick models\n\n\n\n\nSI\n\n\nThe susceptible-infectious (\n\"SI\"\n) is a very basic model with only one type of event. Individuals who become infected remain infected for the duration of trajectory.\n\n\n\n\n\n\nSIR\n\n\nThe classic Kermack-McKendrick susceptible-infectious-recovered (\n\"SIR\"\n) model.\n\n\n\n\n\n\nSIS\n\n\n\n\nThe susceptible-infectious-susceptible (\n\"SIS\"\n) model is an extension of the classic Kermack-McKendrick (\nSIR\n) model for diseases which do not confer lasting immunity.\n\n\n\n\n\n\nSIRS\n\n\nThe susceptible-infectious-recovered-susceptible (\n\"SIRS\"\n) model incorporates all of the above, i.e. it is for diseases which do not confer long lasting immunity.\n\n\n\n\n\n\nLatent Kermack-McKendrick models\n\n\nThe next class of models extend the classic Kermack-McKendrick by accounting for an exposed state \nE\n between infection and the onset of infectiousness.\n\n\n\n\nSEI\n\n\nThe susceptible-exposed-infectious (\n\"SEI\"\n model.\n\n\n\n\n\n\nSEIR\n\n\n\n\n\n\nSEIS\n\n\n\n\nSEIRS\n\n\n\n\nMiscellaneous\n\n\n\n\nLotka-Volterra predator-prey model\n\n\nThe Lotka-Volterra model is well known for its application to predator-prey interactions but can also be used to model chemical, bio molecular and other auto regulating biological systems. Compartments are labelled Predator, pRey. The \nmodel.rate_function\n for prey reproduction, predator reproduction and predator death is defined as:\n\n\nfunction lotka_rf(output, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n  # prey; predator reproduction; predator death\n  output[1] = parameters[1] * population[2]\n  output[2] = parameters[2] * population[1] * population[2]\n  output[3] = parameters[3] * population[1]\nend\n\n\n\n\nwith the transition matrix given as:\n\n\nm_transition = [ 0 1; 1 -1; -1  0 ]\n\n\n\n\n\n\nRoss-MacDonald predator-prey model\n\n\n\n\nSETIR model for bTB\n\n\n\n\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n@article{pizza2000identification,\n  title={Identification of vaccine candidates against serogroup B meningococcus by whole-genome sequencing},\n  author={Pizza, Mariagrazia and Scarlato, Vincenzo and Masignani, Vega and Giuliani, Marzia Monica and Arico, Beatrice and Comanducci, Maurizio and Jennings, Gary T and Baldi, Lucia and Bartolini, Erika and Capecchi, Barbara and others},\n  journal={Science},\n  volume={287},\n  number={5459},\n  pages={1816--1820},\n  year={2000},\n  publisher={American Association for the Advancement of Science}\n}\n@book{book1,\n  author = \"Donald Knuth\",\n  title = \"Concrete Mathematics\"\n}", 
            "title": "Models"
        }, 
        {
            "location": "/models/#discuitjl-models", 
            "text": "Discuit comes with a number of well known, mostly epidemiological models pre defined. This section describes the models and how to use them.", 
            "title": "Discuit.jl models"
        }, 
        {
            "location": "/models/#model-builder", 
            "text": "Pre defined models can be invoked by calling:  generate_model(model_name, initial_condition, \u03c3 = 2.0)   Examples   model = generate_model( SIS , [100, 1]]);\nmodel = generate_model( SEIR , [100, 0, 1, 0]], 1.0)", 
            "title": "Model builder"
        }, 
        {
            "location": "/models/#defaults", 
            "text": "Discuit.jl models  are  mutable struct s so it is convenient to generate pre defined with default values for most things and allow the user to overwrite as required. Only the 'model*name' and  initial*condition are required to call generate_model . The following gives an overview of important defaults that the user should note before proceeding with their analysis.", 
            "title": "Defaults"
        }, 
        {
            "location": "/models/#observation-function", 
            "text": "The default  model.obs_function  is YET TO BE DETERMINED...", 
            "title": "Observation function"
        }, 
        {
            "location": "/models/#observation-likelihood-model", 
            "text": "The default  model.observation_model  is Gaussian with observation error  \u03c3 = 2.0  by default, which can be changed by providing an optional third parameter to  generate_model  per the example above,  ADD EQNS", 
            "title": "Observation likelihood model"
        }, 
        {
            "location": "/models/#prior-density-function", 
            "text": "The default  model.prior  density function is weak, e.g. in a simple two parameter model it is equivalent to:  function weak_prior(parameters::Array{Float64, 1})\n    parameters[1]   0.0 || return 0.0\n    parameters[2]   0.0 || return 0.0\n    return 1.0\nend  Note that all models generated by the ADD XREF have  t0_index = 0  by default and that changing this parameter will likely require replacing the the density with something like:  function weak_prior(parameters::Array{Float64, 1})\n    parameters[1]   0.0 || return 0.0\n    parameters[2]   0.0 || return 0.0\n    parameters[3]   0.0 || return 0.0\n    return 1.0\nend  where  parameters[3]  is designated as the, e.g. initial infection, which is assumed to have taken place prior to e.g. the initial observation at t = 0.0. ADD LATEX...", 
            "title": "Prior density function"
        }, 
        {
            "location": "/models/#classic-kermack-mckendrick-models", 
            "text": "", 
            "title": "Classic Kermack-McKendrick models"
        }, 
        {
            "location": "/models/#si", 
            "text": "The susceptible-infectious ( \"SI\" ) is a very basic model with only one type of event. Individuals who become infected remain infected for the duration of trajectory.", 
            "title": "SI"
        }, 
        {
            "location": "/models/#sir", 
            "text": "The classic Kermack-McKendrick susceptible-infectious-recovered ( \"SIR\" ) model.", 
            "title": "SIR"
        }, 
        {
            "location": "/models/#sis", 
            "text": "The susceptible-infectious-susceptible ( \"SIS\" ) model is an extension of the classic Kermack-McKendrick ( SIR ) model for diseases which do not confer lasting immunity.", 
            "title": "SIS"
        }, 
        {
            "location": "/models/#sirs", 
            "text": "The susceptible-infectious-recovered-susceptible ( \"SIRS\" ) model incorporates all of the above, i.e. it is for diseases which do not confer long lasting immunity.", 
            "title": "SIRS"
        }, 
        {
            "location": "/models/#latent-kermack-mckendrick-models", 
            "text": "The next class of models extend the classic Kermack-McKendrick by accounting for an exposed state  E  between infection and the onset of infectiousness.", 
            "title": "Latent Kermack-McKendrick models"
        }, 
        {
            "location": "/models/#sei", 
            "text": "The susceptible-exposed-infectious ( \"SEI\"  model.", 
            "title": "SEI"
        }, 
        {
            "location": "/models/#seir", 
            "text": "", 
            "title": "SEIR"
        }, 
        {
            "location": "/models/#seis", 
            "text": "", 
            "title": "SEIS"
        }, 
        {
            "location": "/models/#seirs", 
            "text": "", 
            "title": "SEIRS"
        }, 
        {
            "location": "/models/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/models/#lotka-volterra-predator-prey-model", 
            "text": "The Lotka-Volterra model is well known for its application to predator-prey interactions but can also be used to model chemical, bio molecular and other auto regulating biological systems. Compartments are labelled Predator, pRey. The  model.rate_function  for prey reproduction, predator reproduction and predator death is defined as:  function lotka_rf(output, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n  # prey; predator reproduction; predator death\n  output[1] = parameters[1] * population[2]\n  output[2] = parameters[2] * population[1] * population[2]\n  output[3] = parameters[3] * population[1]\nend  with the transition matrix given as:  m_transition = [ 0 1; 1 -1; -1  0 ]", 
            "title": "Lotka-Volterra predator-prey model"
        }, 
        {
            "location": "/models/#ross-macdonald-predator-prey-model", 
            "text": "", 
            "title": "Ross-MacDonald predator-prey model"
        }, 
        {
            "location": "/models/#setir-model-for-btb", 
            "text": "", 
            "title": "SETIR model for bTB"
        }, 
        {
            "location": "/models/#references", 
            "text": "@article{pizza2000identification,\n  title={Identification of vaccine candidates against serogroup B meningococcus by whole-genome sequencing},\n  author={Pizza, Mariagrazia and Scarlato, Vincenzo and Masignani, Vega and Giuliani, Marzia Monica and Arico, Beatrice and Comanducci, Maurizio and Jennings, Gary T and Baldi, Lucia and Bartolini, Erika and Capecchi, Barbara and others},\n  journal={Science},\n  volume={287},\n  number={5459},\n  pages={1816--1820},\n  year={2000},\n  publisher={American Association for the Advancement of Science}\n}\n@book{book1,\n  author = \"Donald Knuth\",\n  title = \"Concrete Mathematics\"\n}", 
            "title": "References"
        }, 
        {
            "location": "/manual/", 
            "text": "Discuit.jl manual\n\n\nSee \nDiscuit.jl examples\n for a brief introduction to the package's core functionality.\n\n\n\n\nContents\n\n\n\n\nDiscuit.jl manual\n\n\nContents\n\n\nTypes\n\n\nFunctions\n\n\ncore functionality\n\n\nmodel helpers\n\n\nutilities\n\n\ncustom MCMC\n\n\n\n\n\n\nIndex\n\n\nReferences\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nDiscuit.DiscuitModel\n \n \nType\n.\n\n\nDiscuitModel\n\n\n\n\nFields\n\n\n\n\nmodel_name\n          \u2013 string, e,g, \n\"SIR\"\n.\n\n\nrate_function\n       \u2013 event rate function.\n\n\nm_transition\n        \u2013 transition matrix.\n\n\nt0_index\n            \u2013 index of the parameter that represents the initial time. \n0\n if fixed at \n0.0\n.\n\n\ninitial_condition\n   \u2013 initial condition\n\n\nobs_function\n        \u2013 observation function.\n\n\nprior_density\n       \u2013 prior density function.\n\n\nobservation_model\n   \u2013 observation likelihood model.\n\n\n\n\nA \nmutable struct\n which represents a DSSCT model (see \nDiscuit.jl models\n for further details).\n\n\nsource\n\n\n#\n\n\nDiscuit.SimResults\n \n \nType\n.\n\n\nSimResults\n\n\n\n\nFields\n\n\n\n\ntrajectory\n      \u2013 array of type \nEvent\n.\n\n\nobservations\n    \u2013 variable of type \nObservations\n.\n\n\n\n\nThe results of a simulation.\n\n\nsource\n\n\n#\n\n\nDiscuit.Observations\n \n \nType\n.\n\n\nObservations\n\n\n\n\nFields\n\n\n\n\ntime\n    \u2013 observation times.\n\n\nval\n     \u2013 observation values.\n\n\n\n\nStores one column vector of observation times and one or more column vectors of observation integer values.\n\n\nsource\n\n\n#\n\n\nDiscuit.MCMCResults\n \n \nType\n.\n\n\nMCMCResults\n\n\n\n\nFields\n\n\n\n\nsamples\n     \u2013 two dimensional array of samples.\n\n\nmc_accepted\n \u2013 proposal accepted\n\n\nmean\n        \u2013 sample mean.\n\n\ncovar\n       \u2013 parameter covariance matrix.\n\n\n\n\nThe results of an MCMC analysis including samples; mean; covariance matrix; adaptation period; and results of the Geweke test of stationarity.\n\n\nsource\n\n\n#\n\n\nDiscuit.GelmanResults\n \n \nType\n.\n\n\nGelmanResults\n\n\n\n\nFields\n\n\n\n\nmu\n      \u2013 between chain sample mean.\n\n\nsre\n     \u2013 scale reduction factor estimate.\n\n\nsre_ll\n  \u2013 scale reduction factor lower confidence interval.\n\n\nsre_ul\n  \u2013 scale reduction factor upper confidence interval.\n\n\nmcmc\n    \u2013 array of \nMCMCResults\n\n\n\n\nResults of a Gelman Rubin convergence diagnostic including n \nMCMCResults\n variables; \nmu\n; and the scale reduction factor estimates (\nsre\n).\n\n\nsource\n\n\n\n\nFunctions\n\n\nThis section is organised in three parts:\n\n\n\n\nthe main package \ncore functionality\n for working with standard Discuit models\n\n\nutilities\n, for loading to and from file\n\n\ncustom MCMC\n, for running custom algorithms\n\n\n\n\n\n\ncore functionality\n\n\n#\n\n\nDiscuit.set_random_seed\n \n \nFunction\n.\n\n\nset_random_seed(seed)\n\n\n\n\nExamples\n\n\nset_random_seed(1234)\n\n\n\n\nDoes what it says on the tin but only if you give it an integer.\n\n\nsource\n\n\n#\n\n\nDiscuit.gillespie_sim\n \n \nFunction\n.\n\n\ngillespie_sim(model, parameters, tmax = 100.0, num_obs = 5)\n\n\n\n\nParameters\n\n\n\n\nmodel\n       \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nparameters\n  \u2013 model parameters.\n\n\ntmax\n        \u2013 maximum time.\n\n\nnum_obs\n     \u2013 number of observations to draw,\n\n\n\n\nRun a DGA simulation on \nmodel\n. Returns a SimResults containing the trajectory and observations data.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_met_hastings_mcmc\n \n \nFunction\n.\n\n\nrun_met_hastings_mcmc(model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\ninitial_parameters\n  \u2013 initial model parameters (i.e. sample).\n\n\nsteps\n               \u2013 number of iterations.\n\n\nmbp\n                 \u2013 model based proposals (MBP). Set \nmbp = false\n for standard proposals.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.\n\n\n\n\nRun an MCMC analysis based on \nmodel\n and \nobs_data\n of type \nObservations\n. The number of samples obtained is equal to \nsteps\n - \nadapt_period\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_custom_mcmc\n \n \nFunction\n.\n\n\nrun_custom_mcmc(model, obs_data, proposal_function, x0, steps = 50000, adapt_period = 10000, prop_param = false, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\nproposal_function\n   \u2013 \nFunction\n for proposing changes to the trajectory. Must have the signature: \ncustom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)\n\n\nx0\n                  \u2013 \nMarkovState\n representing the initial sample and trajectory.\n\n\nsteps\n               \u2013 number of iterations.\n\n\nadapt_period\n        \u2013 burn in period.\n\n\nprop_param\n          \u2013 simulaneously propose changes to parameters. Default: \nfalse\n.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not relevant if \nprop_param = true\n.\n\n\n\n\nRun a custom MCMC analysis. Similar to \nrun_met_hastings_mcmc\n except that the\nproposal_function\n (of type Function) and initial state \nx0\n (of type MarkovState) are user defined.\n\n\nsource\n\n\n#\n\n\nDiscuit.run_gelman_diagnostic\n \n \nFunction\n.\n\n\nrun_gelman_diagnostic(m_model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)\n\n\n\n\nParameters\n\n\n\n\nmodel\n               \u2013 \nDiscuitModel\n (see [Discuit.jl models]@ref).\n\n\nobs_data\n            \u2013 \nObservations\n data.\n\n\ninitial_parameters\n  \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.\n\n\nsteps\n               \u2013 number of iterations.\n\n\nadapt_period\n        \u2013 number of discarded samples.\n\n\nmbp\n                 \u2013 model based proposals (MBP). Set \nmbp = false\n for standard proposals.\n\n\nppp\n                 \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.\n\n\n\n\nRun n (equal to the number of rows in \ninitial_parameters\n)  MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.\n\n\nsource\n\n\n#\n\n\nDiscuit.compute_autocorrelation\n \n \nFunction\n.\n\n\ncompute_autocorrelation(mcmc, lags = 200)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n    \u2013 \nMCMCResults\n variable.\n\n\nlags\n    \u2013 the number of lags to compute. Default: 200.\n\n\n\n\nCompute autocorrelation R for a single Markov chain.\n\n\nsource\n\n\ncompute_autocorrelation(mcmc, lags = 200)\n\n\n\n\nParameters\n\n\n\n\nmcmc\n    \u2013 an array of \nMCMCResults\n variables.\n\n\nlags\n    \u2013 the number of lags to compute. Default: 200.\n\n\n\n\nCompute autocorrelation R' for a two or more Markov chains.\n\n\nsource\n\n\n\n\nmodel helpers\n\n\nDiscuit.jl\n includes tools for generating components which can help minimise the amount of work required to generate customised \nDiscuitModel\ns, including \ngenerate_model(...)\n which is used to access a library of pre defined \nDiscuit.jl models\n.\n\n\n#\n\n\nDiscuit.generate_generic_obs_function\n \n \nFunction\n.\n\n\ngenerate_generic_obs_function()\n\n\n\n\nExamples\n\n\ngenerate_generic_obs_function()\n\n\n\n\nGenerates a simple observation function for use in a \nDiscuitModel\n. Not very realistic...\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_weak_prior\n \n \nMethod\n.\n\n\ngenerate_weak_prior(n)\n\n\n\n\nParameters\n\n\n\n\nn\n   \u2013 the number of parameters in the model.\n\n\n\n\nExamples\n\n\ngenerate_weak_prior(1)\n\n\n\n\nGenerate a \"weak\" prior density function, where \nn\n is the number of parameters in the model.\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_gaussian_obs_model\n \n \nFunction\n.\n\n\ngenerate_gaussian_obs_model(n, \u03c3 = 2.0)\n\n\n\n\nParameters\n\n\n\n\nn\n   \u2013 the number of discrete states in the model.\n\n\n\u03c3\n   \u2013 observation error.\n\n\n\n\ntest latex eqn:\n\n\n\n\n\n\frac{n!}{k!(n - k)!} = \binom{n}{k}\n\n\n\n\n\nExamples\n\n\np = generate_weak_prior(1)\n\n\n\n\nGenerate a Gaussian observation model for a model with \nn\n states. Optionally specify observation error \n\u03c3\n.\n\n\nsource\n\n\n#\n\n\nDiscuit.generate_model\n \n \nFunction\n.\n\n\ngenerate_model(model_name, initial_condition, \u03c3 = 2.0)\n\n\n\n\nParameters\n\n\n\n\nmodel_name\n          \u2013 the model, e.g. \"SI\"; \"SIR\"; \"SEIR\"; etc\n\n\ninitial_condition\n   \u2013 initial condition.\n\n\n\u03c3\n                   \u2013 observation error.\n\n\n\n\nmodel_name\n \noptions\n\n\n\n\n\"SI\"\n\n\n\"SIR\"\n\n\n\"SIS\"\n\n\n\"SEI\"\n\n\n\"SEIR\"\n\n\n\"SEIS\"\n\n\n\"SEIRS\"\n\n\n\"PREDPREY\"\n\n\n\"ROSSMAC\"\n\n\n\n\nExamples\n\n\ngenerate_model(\nSIS\n, [100,1])\n\n\n\n\nGenerates a \nDiscuitModel\n. Optionally specify observation error \n\u03c3\n.\n\n\nsource\n\n\n\n\nutilities\n\n\nprint_trajectory\nprint_observations\nread_observations_data_from_file\nget_observations_from_array\nprint_mcmc_results\nprint_gelman_results\nprint_autocorrelation\n\n\n\n\n\n\ncustom MCMC\n\n\ngenerate_custom_x0\nrun_custom_mcmc\nrun_custom_mcmc_gelman_diagnostic\n\n\n\n\n\n\nIndex\n\n\n\n\nDiscuit\n\n\nDiscuit.DiscuitModel\n\n\nDiscuit.GelmanResults\n\n\nDiscuit.MCMCResults\n\n\nDiscuit.Observations\n\n\nDiscuit.SimResults\n\n\nDiscuit.compute_autocorrelation\n\n\nDiscuit.generate_gaussian_obs_model\n\n\nDiscuit.generate_generic_obs_function\n\n\nDiscuit.generate_model\n\n\nDiscuit.generate_weak_prior\n\n\nDiscuit.get_observations_from_array\n\n\nDiscuit.gillespie_sim\n\n\nDiscuit.print_autocorrelation\n\n\nDiscuit.print_gelman_results\n\n\nDiscuit.print_mcmc_results\n\n\nDiscuit.print_observations\n\n\nDiscuit.print_trajectory\n\n\nDiscuit.run_custom_mcmc\n\n\nDiscuit.run_custom_mcmc_gelman_diagnostic\n\n\nDiscuit.run_gelman_diagnostic\n\n\nDiscuit.run_met_hastings_mcmc\n\n\nDiscuit.set_random_seed\n\n\n\n\n\n\nReferences\n\n\nTBA", 
            "title": "Manual"
        }, 
        {
            "location": "/manual/#discuitjl-manual", 
            "text": "See  Discuit.jl examples  for a brief introduction to the package's core functionality.", 
            "title": "Discuit.jl manual"
        }, 
        {
            "location": "/manual/#contents", 
            "text": "Discuit.jl manual  Contents  Types  Functions  core functionality  model helpers  utilities  custom MCMC    Index  References", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/#types", 
            "text": "#  Discuit.DiscuitModel     Type .  DiscuitModel  Fields   model_name           \u2013 string, e,g,  \"SIR\" .  rate_function        \u2013 event rate function.  m_transition         \u2013 transition matrix.  t0_index             \u2013 index of the parameter that represents the initial time.  0  if fixed at  0.0 .  initial_condition    \u2013 initial condition  obs_function         \u2013 observation function.  prior_density        \u2013 prior density function.  observation_model    \u2013 observation likelihood model.   A  mutable struct  which represents a DSSCT model (see  Discuit.jl models  for further details).  source  #  Discuit.SimResults     Type .  SimResults  Fields   trajectory       \u2013 array of type  Event .  observations     \u2013 variable of type  Observations .   The results of a simulation.  source  #  Discuit.Observations     Type .  Observations  Fields   time     \u2013 observation times.  val      \u2013 observation values.   Stores one column vector of observation times and one or more column vectors of observation integer values.  source  #  Discuit.MCMCResults     Type .  MCMCResults  Fields   samples      \u2013 two dimensional array of samples.  mc_accepted  \u2013 proposal accepted  mean         \u2013 sample mean.  covar        \u2013 parameter covariance matrix.   The results of an MCMC analysis including samples; mean; covariance matrix; adaptation period; and results of the Geweke test of stationarity.  source  #  Discuit.GelmanResults     Type .  GelmanResults  Fields   mu       \u2013 between chain sample mean.  sre      \u2013 scale reduction factor estimate.  sre_ll   \u2013 scale reduction factor lower confidence interval.  sre_ul   \u2013 scale reduction factor upper confidence interval.  mcmc     \u2013 array of  MCMCResults   Results of a Gelman Rubin convergence diagnostic including n  MCMCResults  variables;  mu ; and the scale reduction factor estimates ( sre ).  source", 
            "title": "Types"
        }, 
        {
            "location": "/manual/#functions", 
            "text": "This section is organised in three parts:   the main package  core functionality  for working with standard Discuit models  utilities , for loading to and from file  custom MCMC , for running custom algorithms", 
            "title": "Functions"
        }, 
        {
            "location": "/manual/#core-functionality", 
            "text": "#  Discuit.set_random_seed     Function .  set_random_seed(seed)  Examples  set_random_seed(1234)  Does what it says on the tin but only if you give it an integer.  source  #  Discuit.gillespie_sim     Function .  gillespie_sim(model, parameters, tmax = 100.0, num_obs = 5)  Parameters   model        \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  parameters   \u2013 model parameters.  tmax         \u2013 maximum time.  num_obs      \u2013 number of observations to draw,   Run a DGA simulation on  model . Returns a SimResults containing the trajectory and observations data.  source  #  Discuit.run_met_hastings_mcmc     Function .  run_met_hastings_mcmc(model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  initial_parameters   \u2013 initial model parameters (i.e. sample).  steps                \u2013 number of iterations.  mbp                  \u2013 model based proposals (MBP). Set  mbp = false  for standard proposals.  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.   Run an MCMC analysis based on  model  and  obs_data  of type  Observations . The number of samples obtained is equal to  steps  -  adapt_period .  source  #  Discuit.run_custom_mcmc     Function .  run_custom_mcmc(model, obs_data, proposal_function, x0, steps = 50000, adapt_period = 10000, prop_param = false, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  proposal_function    \u2013  Function  for proposing changes to the trajectory. Must have the signature:  custom_proposal(model::PrivateDiscuitModel, xi::MarkovState, xf_parameters::ParameterProposal) = MarkovState(...)  x0                   \u2013  MarkovState  representing the initial sample and trajectory.  steps                \u2013 number of iterations.  adapt_period         \u2013 burn in period.  prop_param           \u2013 simulaneously propose changes to parameters. Default:  false .  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not relevant if  prop_param = true .   Run a custom MCMC analysis. Similar to  run_met_hastings_mcmc  except that the proposal_function  (of type Function) and initial state  x0  (of type MarkovState) are user defined.  source  #  Discuit.run_gelman_diagnostic     Function .  run_gelman_diagnostic(m_model, obs_data, initial_parameters, steps = 50000, adapt_period = 10000, mbp = true, ppp = 0.3)  Parameters   model                \u2013  DiscuitModel  (see [Discuit.jl models]@ref).  obs_data             \u2013  Observations  data.  initial_parameters   \u2013 matrix of initial model parameters. Each column vector correspondes to a single model parameter.  steps                \u2013 number of iterations.  adapt_period         \u2013 number of discarded samples.  mbp                  \u2013 model based proposals (MBP). Set  mbp = false  for standard proposals.  ppp                  \u2013 the proportion of parameter (vs. trajectory) proposals. Default: 30%. NB. not required for MBP.   Run n (equal to the number of rows in  initial_parameters )  MCMC analyses and perform a Gelman-Rubin convergence diagnostic on the results. NEED TO OVERLOAD AND EXPAND.  source  #  Discuit.compute_autocorrelation     Function .  compute_autocorrelation(mcmc, lags = 200)  Parameters   mcmc     \u2013  MCMCResults  variable.  lags     \u2013 the number of lags to compute. Default: 200.   Compute autocorrelation R for a single Markov chain.  source  compute_autocorrelation(mcmc, lags = 200)  Parameters   mcmc     \u2013 an array of  MCMCResults  variables.  lags     \u2013 the number of lags to compute. Default: 200.   Compute autocorrelation R' for a two or more Markov chains.  source", 
            "title": "core functionality"
        }, 
        {
            "location": "/manual/#model-helpers", 
            "text": "Discuit.jl  includes tools for generating components which can help minimise the amount of work required to generate customised  DiscuitModel s, including  generate_model(...)  which is used to access a library of pre defined  Discuit.jl models .  #  Discuit.generate_generic_obs_function     Function .  generate_generic_obs_function()  Examples  generate_generic_obs_function()  Generates a simple observation function for use in a  DiscuitModel . Not very realistic...  source  #  Discuit.generate_weak_prior     Method .  generate_weak_prior(n)  Parameters   n    \u2013 the number of parameters in the model.   Examples  generate_weak_prior(1)  Generate a \"weak\" prior density function, where  n  is the number of parameters in the model.  source  #  Discuit.generate_gaussian_obs_model     Function .  generate_gaussian_obs_model(n, \u03c3 = 2.0)  Parameters   n    \u2013 the number of discrete states in the model.  \u03c3    \u2013 observation error.   test latex eqn:   \n\frac{n!}{k!(n - k)!} = \binom{n}{k}   Examples  p = generate_weak_prior(1)  Generate a Gaussian observation model for a model with  n  states. Optionally specify observation error  \u03c3 .  source  #  Discuit.generate_model     Function .  generate_model(model_name, initial_condition, \u03c3 = 2.0)  Parameters   model_name           \u2013 the model, e.g. \"SI\"; \"SIR\"; \"SEIR\"; etc  initial_condition    \u2013 initial condition.  \u03c3                    \u2013 observation error.   model_name   options   \"SI\"  \"SIR\"  \"SIS\"  \"SEI\"  \"SEIR\"  \"SEIS\"  \"SEIRS\"  \"PREDPREY\"  \"ROSSMAC\"   Examples  generate_model( SIS , [100,1])  Generates a  DiscuitModel . Optionally specify observation error  \u03c3 .  source", 
            "title": "model helpers"
        }, 
        {
            "location": "/manual/#utilities", 
            "text": "print_trajectory\nprint_observations\nread_observations_data_from_file\nget_observations_from_array\nprint_mcmc_results\nprint_gelman_results\nprint_autocorrelation", 
            "title": "utilities"
        }, 
        {
            "location": "/manual/#custom-mcmc", 
            "text": "generate_custom_x0\nrun_custom_mcmc\nrun_custom_mcmc_gelman_diagnostic", 
            "title": "custom MCMC"
        }, 
        {
            "location": "/manual/#index", 
            "text": "Discuit  Discuit.DiscuitModel  Discuit.GelmanResults  Discuit.MCMCResults  Discuit.Observations  Discuit.SimResults  Discuit.compute_autocorrelation  Discuit.generate_gaussian_obs_model  Discuit.generate_generic_obs_function  Discuit.generate_model  Discuit.generate_weak_prior  Discuit.get_observations_from_array  Discuit.gillespie_sim  Discuit.print_autocorrelation  Discuit.print_gelman_results  Discuit.print_mcmc_results  Discuit.print_observations  Discuit.print_trajectory  Discuit.run_custom_mcmc  Discuit.run_custom_mcmc_gelman_diagnostic  Discuit.run_gelman_diagnostic  Discuit.run_met_hastings_mcmc  Discuit.set_random_seed", 
            "title": "Index"
        }, 
        {
            "location": "/manual/#references", 
            "text": "TBA", 
            "title": "References"
        }
    ]
}